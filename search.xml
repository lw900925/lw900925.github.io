<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker：容器编排利器Compose（起步篇）</title>
    <url>/docker/docker-compose-getting-started.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/docker-logo.jpeg"></p>
<p>一个大型的Docker组成的微服务应用中，容器的数量是非常庞大的，如果依赖传统的人工配置方式进行维护，对于开发和运维来说简直就是噩梦。Compose的出现正是为了解决这个问题。</p>
<a id="more"></a>
<h2 id="Compose简介"><a href="#Compose简介" class="headerlink" title="Compose简介"></a>Compose简介</h2><p>Compose的前身是Fig，Fig被Docker收购之后正式更名为Compose，Compose向下兼容Fig。Compose是一个用于定义和运行多容器Docker应用的工具，只需要一个Compose的配置文件和一个简单的命令就可以创建并运行应用所需的所有容器。在配置文件中，所有容器通过<code>services</code>来定义，并使用<code>docker-compose</code>命令启动或停止容器以及所有依赖容器。</p>
<h2 id="安装Compose"><a href="#安装Compose" class="headerlink" title="安装Compose"></a>安装Compose</h2><p>Compose的安装方式有多种，这里推荐使用<code>curl</code>命令安装，在安装之前，要确保你的机器上已经安装了Docker，可以运行<code>sudo docker version</code>命令来确认是否已安装了Docker。截至目前，Compose的最新发布版为<code>1.11.2</code>，下面演示在一台已经安装好Docker的Linux主机上安装Compose。</p>
<p>安装很简单，只需要执行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.11.2/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>等待安装完毕后，执行下面的命令，为<code>docker-compose</code>添加可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>输入<code>docker-compose --version</code>命令可以查看安装结果。</p>
<p>除了这种安装方式之外，还可以通过Python的<code>pip</code>命令安装或将Compose安装成Docker容器，详情请参见<a href="https://docs.docker.com/compose/install/#install-as-a-container" title="https://docs.docker.com/compose/install/#install-as-a-container" target="_blank" rel="noopener">https://docs.docker.com/compose/install/#install-as-a-container</a>。</p>
<p>如果要卸载Compose，可以执行<code>sudo rm /usr/local/bin/docker-compose</code>命令。</p>
<h2 id="Compose入门"><a href="#Compose入门" class="headerlink" title="Compose入门"></a>Compose入门</h2><p>下面我们通过一个简单的例子演示Compose的使用步骤，使用Python构建一个Web应用，该应用使用Flask框架，并在Redis中维护一个命中计数（即使你不熟悉Python也没有关系，你甚至不需要安装Python和Redis，我们会从容器中获取这些依赖环境）。</p>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>首先需要一个文件夹作为项目文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line"><span class="built_in">cd</span> composetest</span><br></pre></td></tr></table></figure>
<p>在项目文件夹下创建一个<code>app.py</code>的文件，并将下面的代码拷贝并粘贴到该文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>在项目文件夹下创建一个<code>requirements.txt</code>的文件，并将下面的代码拷贝并粘贴到该文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<p>到此，我们已经完成了新建项目，编码，添加依赖等工作。</p>
<h3 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h3><p>下面我们创建一个<code>Dockerfile</code>文件用于构建Docker镜像，该镜像包含了运行该Web应用的所有依赖，包括Python运行环境。</p>
<p>在项目文件夹下创建一个<code>Dockerfile</code>文件，并将下面的内容拷贝并粘贴到该文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM python:3.4-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<p>大概解释一下这个配置文件：</p>
<ul>
<li>使用<code>python-3.4-alpine</code>作为基础镜像</li>
<li>将当前目录添加到镜像中<code>/code</code>目录下</li>
<li>将<code>/code</code>设置为工作目录</li>
<li>安装Python依赖</li>
<li>设置默认执行命令</li>
</ul>
<h3 id="在Compose文件中定义services"><a href="#在Compose文件中定义services" class="headerlink" title="在Compose文件中定义services"></a>在Compose文件中定义services</h3><p>在项目文件夹下创建一个<code>docker-compose.yml</code>文件，并将下面的内容拷贝并粘贴到该文件中：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure>
<p>该配置文件中包含两个<code>services</code>，即<code>web</code>和<code>redis</code>。<code>web</code>会使用当前目录中的<code>Dockerfile</code>文件构建镜像，并将容器的<code>5000</code>端口暴露给主机，然后将项目文件夹挂载到容器中的<code>/code</code>目录下；<code>redis</code>使用官方发布的镜像构建。</p>
<h3 id="构建并运行"><a href="#构建并运行" class="headerlink" title="构建并运行"></a>构建并运行</h3><p>执行下面的命令构建并运行容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up</span><br></pre></td></tr></table></figure>
<p>容器构建完成并启动后，可以在浏览器中输入<code>http://localhost:5000</code>查看结果。页面会打印“Hello World! I have been seen 1 times.”，刷新页面后，计数会累加变成2。</p>
<h3 id="更新应用"><a href="#更新应用" class="headerlink" title="更新应用"></a>更新应用</h3><p>由于项目文件夹挂载到了容器中，所以我们可以直接修改项目文件夹的应用，修改的结果立即反应到容器中，而不用重新启动容器。将<code>app.py</code>文件中的<code>hello</code>方法中的返回值修改成如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">'Hello from Docker! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br></pre></td></tr></table></figure>
<p>保存后刷新浏览器，发现打印结果已经更新。</p>
<h2 id="Compose的其他命令"><a href="#Compose的其他命令" class="headerlink" title="Compose的其他命令"></a>Compose的其他命令</h2><p>上面提到的Componse使用命令构建并启动容器，是以前台的方式启动的，如果希望以后台启动，可以添加参数<code>-d</code>，比如下面这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>
<p><code>docker-compose ps</code>命令可以查看正在运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">liuwei@liuwei-Ubuntu:~$ sudo docker-compose ps</span><br><span class="line">Name                      Command               State           Ports</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">composetest_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp</span><br><span class="line">composetest_web_1     python app.py                    Up      0.0.0.0:5000-&gt;5000/tcp</span><br></pre></td></tr></table></figure>
<p>如果使用<code>sudo docker-compose up -d</code>命令以后台方式启动，可以用<code>docker-compose stop</code>命令停止。<code>docker-compose down --volumes</code>命令可以停止容器并将其删除，<code>--volumns</code>表示同时删除redis数据文件目录。</p>
<p>有关Compose的更多命令，可以通过<code>sudo docker-compose --help</code>查看。</p>
<p>以上就是Compose的一个基本使用过程，可以发现，Compose将<code>docker run</code>命令整合到了一个<code>docker-compose.yml</code>配置文件中，对于大型Docker集群的管理是很方便的，例可以将多个<code>service</code>组合成更复杂的<code>service</code>组，为每个<code>service</code>指定不同的<code>Dockerfile</code>，然后把它们<code>link</code>在一起。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker：自定义镜像仓库</title>
    <url>/docker/docker-custom-repository.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/docker-logo.jpeg"></p>
<p>从阿里云提供的镜像仓库获取Docker镜像。</p>
<a id="more"></a>
<p>由于国内网络问题，使用官方的Docker Hub上<code>pull</code>一个镜像非常慢，并且时不时会连接超时，所以有必要使用国内提供的镜像仓库。</p>
<h2 id="国内镜像仓库"><a href="#国内镜像仓库" class="headerlink" title="国内镜像仓库"></a>国内镜像仓库</h2><p>国内的镜像仓库提供者有：</p>
<ul>
<li><a href="https://dashboard.daocloud.io/" title="DaoCloud - Docker加速器" target="_blank" rel="noopener">DaoCloud - Docker加速器</a></li>
<li><a href="https://dev.aliyun.com/" title="阿里云 - 开发者平台" target="_blank" rel="noopener">阿里云 - 开发者平台</a></li>
<li><a href="https://csphere.cn/hub" title="希云cSphere - 微镜像" target="_blank" rel="noopener">希云cSphere - 微镜像</a></li>
<li><a href="https://hub.tenxcloud.com/" title="时速云 - 镜像广场" target="_blank" rel="noopener">时速云 - 镜像广场</a></li>
<li><a href="https://c.163.com/hub#/m/home/" title="网易蜂巢 - 镜像中心" target="_blank" rel="noopener">网易蜂巢 - 镜像中心</a></li>
</ul>
<p>我使用的是阿里云的镜像仓库，下面是具体配置方法。</p>
<h2 id="配置Docker镜像仓库"><a href="#配置Docker镜像仓库" class="headerlink" title="配置Docker镜像仓库"></a>配置Docker镜像仓库</h2><p>首先需要到<a href="https://dev.aliyun.com/" title="阿里云 - 开发者平台" target="_blank" rel="noopener">开发者平台</a>登录阿里云账号（没有的话可以注册一个），登录后点击页面右上角的<a href="https://cr.console.aliyun.com" title="管理中心" target="_blank" rel="noopener">管理中心</a>按钮进入管理控制台，然后点击左侧<a href="https://cr.console.aliyun.com/#/accelerator" title="加速器" target="_blank" rel="noopener">加速器</a>菜单按钮，可以看到为你自己分配的专属加速地址以及不同平台的配置文档。</p>
<p><strong>注意</strong>：第一次进入控制台需要设置一个密码，该密码用于登录Docker镜像仓库，请牢记，后面会用到。</p>
<p>下面内容我直接从阿里云提供的操作文档复制过来了，是Ubuntu版本的详细配置步骤，其他平台可以参考<a href="https://cr.console.aliyun.com/#/accelerator" title="加速器" target="_blank" rel="noopener">此处</a>。</p>
<h3 id="安装／升级你的Docker客户端"><a href="#安装／升级你的Docker客户端" class="headerlink" title="安装／升级你的Docker客户端"></a>安装／升级你的Docker客户端</h3><p>推荐安装<code>1.6.0</code>以上版本的Docker客户端。</p>
<p>您可以通过阿里云的镜像仓库下载：<a href="mirrors.aliyun.com/help/docker-engine" title="mirrors.aliyun.com/help/docker-engine">mirrors.aliyun.com/help/docker-engine</a></p>
<p>或执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure>
<h3 id="如何使用Docker加速器"><a href="#如何使用Docker加速器" class="headerlink" title="如何使用Docker加速器"></a>如何使用Docker加速器</h3><p><strong> 针对Docker客户端版本大于1.10的用户 </strong></p>
<p>您可以通过修改daemon配置文件<code>/etc/docker/daemon.json</code>来使用加速器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://15laodr8.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p><strong> 针对Docker客户的版本小于等于1.10的用户 </strong></p>
<p>或者想配置启动参数，可以使用下面的命令将配置添加到docker daemon的启动参数中。</p>
<p>Ubuntu 12.04 14.04的用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"DOCKER_OPTS=\"\$DOCKER_OPTS --registry-mirror=https://15laodr8.mirror.aliyuncs.com\""</span> | sudo tee -a /etc/default/docker</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
<p>Ubuntu 15.04 16.04的用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo tee /etc/systemd/system/docker.service.d/mirror.conf &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/docker daemon -H fd:// --registry-mirror=https://15laodr8.mirror.aliyuncs.com</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="下载Docker镜像"><a href="#下载Docker镜像" class="headerlink" title="下载Docker镜像"></a>下载Docker镜像</h2><p>上面步骤配置完成后，就可以使用阿里云镜像仓库下载镜像了，首先我们需要登录到阿里云的Registry，运行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker login -u [username] -p [password] -e [email] registry.aliyuncs.com</span><br></pre></td></tr></table></figure>
<p><code>username</code>是登录的用户名，一般为注册时填写的邮箱，<code>password</code>就是首次进入控制台让你设置的密码，<code>email</code>为注册时填写的邮箱。运行命令后如果出现<code>Login Succeeded</code>表示登录成功。</p>
<p>登录成功后就可以下载镜像了，运行下面的命令试试看速度如何：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker pull ubuntu</span><br></pre></td></tr></table></figure>
<p>具体下载的速度还是要取决于你的网络带宽，总体来说比Docker官方镜像仓库要快很多。</p>
<p>这里只说明了阿里云平台的Docker镜像仓库的配置方法，其他Docker仓库供应商的配置大体上比较类似，需要的话可以去查看相关的操作手册。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker：配置HTTP/HTTPS代理</title>
    <url>/docker/docker-http-or-https-proxy.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/docker-logo.jpeg"></p>
<a id="more"></a>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>我在使用Docker的<code>pull</code>命令拉取ELK官方提供的镜像时，会出现无法连接的情况，并且会出现<code>TLS handshake timeout</code>的错误。在搜索相关文章之后得出结论：国内的网络环境不好，导致连接<code>docker.elastic.co</code>失败或无法连接。于是我第一时间想到了代理的方式，好在Docker支持设置代理来访问其他Registry，下面记录整个配置过程。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，你的机器上需要安装好Docker，当我写这篇文章时，Docker的版本为<code>18.03</code>，对于后续版本，本文章的配置方法可能会失效。</p>
<p>此外，还需要准备一个代理服务器，可以正常访问境外网站（如：Google，YouTuBe等）。我用的是VPS搭建的Shadowsocks代理，本机Shadowsocks客户端开启之后可以直接通过<code>http://127.0.0.1:1080/</code>访问境外网站。</p>
<p>假设你的环境也是Ubuntu（其他环境应该也是类似的）。</p>
<h1 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h1><ol>
<li>创建如下路径的目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入到上一步创建的目录下，并在该目录下创建一个名为<code>http-proxy.conf</code>的文件（如：<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>），使用vim编辑文件内容如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://127.0.0.1:1080/"</span> <span class="string">"NO_PROXY=localhost,127.0.0.1,registry.docker-cn.com,hub-mirror.c.163.com"</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>刷新配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>重启Docker服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>查看配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure>
<p>出现如下信息表示配置成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Environment=HTTPS_PROXY=http://127.0.0.1:1080/ NO_PROXY=localhost,127.0.0.1,registry.docker-cn.com,hub-mirror.c.163.com</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>验证配置是否生效</li>
</ol>
<p>重新从<code>docker.elastic.co</code>上拉取<code>elasticsearch</code>镜像，此时已经可以正常连接了，只是速度较慢。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">liuwei@liuwei-Ubuntu:~$ sudo docker pull docker.elastic.co/elasticsearch/elasticsearch:6.2.4</span><br><span class="line">6.2.4: Pulling from elasticsearch/elasticsearch</span><br><span class="line">469cfcc7a4b3: Downloading [==========================&gt;                        ]  38.87MB/73.17MB</span><br><span class="line">8e27facfa9e0: Downloading [===================================&gt;               ]  40.05MB/56.33MB</span><br><span class="line">cdd15392adc7: Download complete </span><br><span class="line">ddcc70fbd933: Downloading [====================&gt;                              ]  44.31MB/108.9MB</span><br><span class="line">3d3fa0383994: Waiting </span><br><span class="line">15d1376ebd55: Waiting</span><br></pre></td></tr></table></figure>
<p>这种方法适用于从一些第三方提供的Registry上拉取镜像时，由于网络原因无法连接。如果从Docker官方的镜像仓库中拉取镜像时，一种比较好的办法就是配置<code>registry-mirrors</code>实现加速，具体方法请自行搜索。</p>
<p>上述步骤是来自Docker官方文档中的部分，原文地址为<a href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy" target="_blank" rel="noopener">Control Docker with systemd</a>。</p>
<p>如果你在配置过程遇到问题，欢迎在下方评论区留言讨论。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker：创建Redis集群</title>
    <url>/docker/docker-redis-cluster.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/docker-logo.jpeg"></p>
<p>虽然其他网站上有大量关于Docker创建Redis集群的文章，但大多数都比较片面（感觉还是无脑复制粘贴，错误百出），所以决定重新整理一下，把遇到的问题都记录下来。</p>
<a id="more"></a>
<h2 id="获取Redis镜像"><a href="#获取Redis镜像" class="headerlink" title="获取Redis镜像"></a>获取Redis镜像</h2><p>首先从Docker Hub或其他镜像仓库中获取Redis镜像，这里我使用了Docker官方提供的Redis镜像，运行下面命令获取Redis镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull ubuntu</span><br><span class="line">sudo docker pull redis</span><br></pre></td></tr></table></figure>
<p>镜像下载完毕后，执行<code>sudo docker images</code>命令查看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                        latest              e4a35914679d        9 days ago          183 MB</span><br><span class="line">ubuntu                       latest              0ef2e08ed3fa        10 days ago         130 MB</span><br></pre></td></tr></table></figure>
<p>可以看到<code>redis</code>和<code>ubuntu</code>两个镜像已经获取成功，下面开始配置。</p>
<h2 id="配置Redis集群"><a href="#配置Redis集群" class="headerlink" title="配置Redis集群"></a>配置Redis集群</h2><p>在配置Redis集群之前，需要一个<code>redis.conf</code>的配置文件，该配置文件可以从Redis官方站点获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://download.redis.io/redis-stable/redis.conf</span><br></pre></td></tr></table></figure>
<p>等待下载完毕后，将<code>redis.conf</code>拷贝三份，并依次重命名为：<code>redis-master.conf</code>，<code>redis-slave1.conf</code>，<code>redis-slave2.conf</code>，将三个文件放在<code>/home/liuwei/docker/redis/</code>目录中，看起来像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home/liuwei/docker/redis/redis-master.conf</span><br><span class="line">/home/liuwei/docker/redis/redis-slave1.conf</span><br><span class="line">/home/liuwei/docker/redis/redis-slave2.conf</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：这三个文件存放的位置无特殊要求，可以指定任意位置。</p>
<p>将<code>redis-master.conf</code>文件中的配置项做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis.pid</span><br></pre></td></tr></table></figure>
<p>将<code>redis-slave1.conf</code>和<code>redis-slave2.conf</code>文件中的配置项做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line">slaveof master 6379</span><br></pre></td></tr></table></figure>
<p><code>slaveof</code>默认是注释掉的，只需要开启注释即可。需要注意的是<code>slaveof</code>的格式为<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，上面配置中<code>masterip</code>参数为<code>master</code>，实际上是一个别名，稍后会对它进行解释。配置完成后，下一步就是创建Docker容器并启动了。</p>
<h2 id="创建Redis容器"><a href="#创建Redis容器" class="headerlink" title="创建Redis容器"></a>创建Redis容器</h2><p>创建Redis容器只需要使用第一步下载好的Redis镜像，调用Docker的<code>run</code>命令即可，不过要创建一个Redis集群，还需要处理容器与容器之间的通信问题（即Redis的主从复制需要容器之间能够相互连通），这里使用<code>docker run</code>命令的<code>--link</code>参数来建立容器之间的相互连通。</p>
<p>简单介绍一下<code>--link</code>这个参数，<code>--link</code>的使用格式为：<code>name:alias</code>，可以在<code>docker run</code>命令中重复使用该参数，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --name ubuntu ubuntu /bin/bash</span><br><span class="line">sudo docker run -it --name redis --link ubuntu:ubuntu redis /bin/bash</span><br></pre></td></tr></table></figure>
<p>上述命令将使用镜像创建一个名为<code>ubuntu</code>容器，然后创建一个名为<code>redis</code>的容器，将该容器连接到<code>ubuntu</code>容器上。通过<code>--link</code>参数连接的两个容器，可以避免容器的IP和端口暴露到外网导致的安全问题，以及容器在重启后IP地址变化导致访问失效。当容器的IP发生变化时，Docker会自动维护容器中的hosts文件，如果你打开两个通过<code>--link</code>参数连接的容器中的某个容器的<code>/etc/hosts</code>文件，你将看到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line"><span class="comment"># 以下记录了容器的连接信息</span></span><br><span class="line">172.17.0.2	master 385f6821c0db redis-master</span><br><span class="line">172.17.0.3	54466fb83744</span><br></pre></td></tr></table></figure>
<p>通过<code>--link</code>参数，我们可以创建包含一个<code>master</code>和两个<code>slave</code>的Redis集群，使用如下命令创建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -it -v /home/liuwei/docker/redis/redis-master.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf --name redis-master redis /bin/bash</span><br><span class="line">sudo docker run -it -v /home/liuwei/docker/redis/redis-slave1.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf --name redis-slave1 --link redis-master:master redis /bin/bash</span><br><span class="line">sudo docker run -it -v /home/liuwei/docker/redis/redis-slave2.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf --name redis-slave2 --link redis-master:master redis /bin/bash</span><br></pre></td></tr></table></figure>
<p>上述命令中使用<code>--link redis-master:master</code>参数，前面提到的<code>redis-slave.conf</code>配置文件中<code>slaveof</code>配置项，这里使用了一个<code>master</code>作为别名，其效果和使用IP一样（IP地址在<code>/etc/host</code>文件中）。</p>
<p>需要注意的是<code>-v</code>参数，<code>-v</code>参数用于将宿主机上的某个目录挂载到容器中。由于容器都是轻量化设计，只包含运行时的必须文件，所以在容器中使用<code>vim</code>之类的命令很不方便（可能需要自行安装vim编辑器），所以我们将之前配置好的<code>redis.conf</code>文件挂载到对应的容器中。因此，我们可以直接在宿主机上使用<code>vim</code>命令或其他文本编辑器编辑<code>redis.conf</code>文件。</p>
<p><code>-v</code>的格式为：<code>-v /host/path:/container/path</code>，前部分表示主机的目录，后部分表示容器的目录（如果目录不存在，容器启动的时候会自行创建）。</p>
<p>容器启动完毕后，可以运行<code>sudo docker ps</code>查看容器启动状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">d2b29622b98d        redis               &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          6379/tcp                 redis-slave2</span><br><span class="line">54466fb83744        redis               &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          6379/tcp                 redis-slave1</span><br><span class="line">385f6821c0db        redis               &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          6379/tcp                 redis-master</span><br></pre></td></tr></table></figure>
<p>接下来是启动<code>redis</code>服务，这里推荐为每个容器分配一个<code>shell</code>窗口，方便直接在容器内执行命令。先启动<code>master</code>，然后启动<code>slaver</code>。分别在<code>master</code>、<code>slave1</code>和<code>slave2</code>中运行启动<code>redis</code>服务的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<p>启动后，在<code>master</code>容器中执行下面的命令查看<code>redis</code>服务的运行状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此处已省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=172.17.0.4,port=6379,state=online,offset=29,lag=1</span><br><span class="line">slave1:ip=172.17.0.3,port=6379,state=online,offset=29,lag=1</span><br><span class="line">master_repl_offset:29</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:28</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处已省略</span></span><br></pre></td></tr></table></figure>
<p>这里有个坑需要注意一下，我在配置完毕后启动容器，运行<code>info</code>命令查看到上述信息中<code>connected_slaves</code>的值为0，测试主从复制也没有成功，后来搜索了相关资料，需要将<code>redis-master.conf</code>文件中的<code>bind 127.0.0.1</code>修改为<code>bind 0.0.0.0</code>，修改完毕后重启<code>master</code>服务即可。</p>
<blockquote>
<p>评论区有小伙伴提到按照上述修改<code>bind</code>属性后主从依然无法连通，可以尝试将<code>redis-slave1.conf</code>和<code>redis-slave2.conf</code>两个文件都改成<code>bind 0.0.0.0</code>。</p>
</blockquote>
<p>可以看到<code>master</code>中已经包含两个<code>slave</code>，接下来我们测试一下主从复制是否成功，在<code>master</code>容器中输入下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> master liuwei</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get master</span><br><span class="line"><span class="string">"liuwei"</span></span><br></pre></td></tr></table></figure>
<p>然后分别在<code>slave1</code>和<code>slave2</code>容器中执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get master</span><br><span class="line"><span class="string">"liuwei"</span></span><br></pre></td></tr></table></figure>
<p>如果能成功看到输出信息，说明主从复制成功。</p>
<p>相比使用虚拟机搭建Redis集群环境，Docker显得更简单轻量，如果需要配置更多<code>slave</code>，只需要使用命令创建一个容器，连接到<code>master</code>容器。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Docker：Spring Boot应用发布到Docker</title>
    <url>/docker/docker-springboot.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/docker-logo.jpeg"></p>
<p>Spring官网上有一篇<a href="http://spring.io/guides/gs/spring-boot-docker/" title="Getting Start" target="_blank" rel="noopener">Getting Start</a>，介绍了如何使用Docker发布Spring Boot应用，算是比较详细了，不过有些细节没有提及到，而且官网的入门手册是英文版。这里重新整理记录一下，算是给英文不好的小伙伴一个参考，也给自己留个备忘。</p>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要的工具以及运行环境：</p>
<ul>
<li>JDK 1.8 or later</li>
<li>Maven 3.0 +</li>
<li>你喜欢的IDE或其他文本编辑器</li>
</ul>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>首先，你需要创建一个Spring Boot工程，Spring Tool Suite和IntelliJ IDEA都自带插件可以创建，还有一种方式是从<a href="http://start.spring.io/" title="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a>上创建，推荐使用这种方式。填好表单中的<code>Group Id</code>和<code>Artifact Id</code>之后，点击Generate Project按钮就可以生成了，将下载后的工程导入到你喜欢的IDE中。</p>
<p>修改<code>pom.xml</code>文件，添加<code>docker-maven-plugin</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.matrixstudio.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>docker<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">docker.image.prefix</span>&gt;</span>springio<span class="tag">&lt;/<span class="name">docker.image.prefix</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>docker-maven-plugin</code>插件用于将Spring Boot工程构建为Docker镜像：</p>
<ul>
<li><code>imageName</code>表示Docker镜像名称，我们使用Docker的命名规范，命名为：<code>springio/docker</code></li>
<li><code>dockerDirectory</code>表示Dockerfile的路径</li>
<li><code>resource</code>表示在构建时需要的资源文件，这些文件和Dockerfile放在一起，这里只需要Spring Boot生成的jar文件即可。</li>
</ul>
<p>打开<code>DockerApplication.java</code>文件，修改成如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.matrixstudio.springboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Docker World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DockerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译并运行"><a href="#编译并运行" class="headerlink" title="编译并运行"></a>编译并运行</h2><p>执行如下命令运行Spring Boot工程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn package &amp;&amp; java -jar target/docker-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>打开浏览器，输入<code>http://localhost:8080</code>，如果出现“Hello Docker World”说明运行成功。</p>
<p><strong>注</strong>：运行上面的命令时，需要从Maven官方仓库中下载很多依赖包，国内网络不太稳定，下载速度较慢，可考虑使用第三方提供的镜像站，比如阿里的Maven镜像仓库。在<code>pom.xml</code>中加入下面配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.matrixstudio.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Dependencies --&gt;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Build --&gt;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Aliyun repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="容器化项目"><a href="#容器化项目" class="headerlink" title="容器化项目"></a>容器化项目</h2><p>首先要确保你的机器上安装了Docker，如果你的Docker安装在一台Linux服务器上，你需要将上面的Spring Boot工程上传到该服务器上，下面的步骤假设你是在Linux环境上操作。</p>
<h3 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h3><p>Docker使用一个名为<code>Dockerfile</code>的文件来指定image层，所以我们首先需要创建一个<code>Dockerfile</code>文件，执行下面的命令创建<code>Dockerfile</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tee src/main/docker/Dockerfile &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">FROM frolvlad/alpine-oraclejdk8:slim</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">RUN sh -c <span class="string">'touch /app.jar'</span></span><br><span class="line">ENV JAVA_OPTS=<span class="string">""</span></span><br><span class="line">ENTRYPOINT [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"java <span class="variable">$JAVA_OPTS</span> -Djava.security.egd=file:/dev/./urandom -jar /app.jar"</span> ]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>大概解释一下上面的命令：</p>
<ul>
<li><code>VOLUME</code>指向了一个<code>/tmp</code>的目录，由于Spring Boot使用内置的Tomcat容器，Tomcat默认使用<code>/tmp</code>作为工作目录。效果就是在主机的<code>/var/lib/docker</code>目录下创建了一个临时文件，并连接到容器的<code>/tmp</code>。</li>
<li>将项目的jar文件作为<code>app.jar</code>添加到容器</li>
<li><code>RUN</code>表示在新创建的镜像中执行一些命令，然后把执行的结果提交到当前镜像。这里使用<code>touch</code>命令来改变文件的<strong>修改时间</strong>，Docker创建的所有容器文件默认状态都是“未修改”。这对于简单应用来说不需要，不过对于一些静态内容（比如：<code>index.html</code>）的文件就需要一个“修改时间”。</li>
<li>为了缩短Tomcat的启动时间，我们添加一个<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为<code>ENTRYPOINT</code>。</li>
</ul>
<h3 id="构建Docker镜像"><a href="#构建Docker镜像" class="headerlink" title="构建Docker镜像"></a>构建Docker镜像</h3><p>运行下面的命令构建Docker镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure>
<p>构建完成后，运行下面的命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springio/docker              latest              7e2ba2f7e81e        2 minutes ago       195 MB</span><br><span class="line">frolvlad/alpine-oraclejdk8   slim                00d8610f052e        4 days ago          167 MB</span><br></pre></td></tr></table></figure>
<p>可以看到我们构建的镜像已经出现了，下一步就是运行该镜像。</p>
<h3 id="运行Docker镜像"><a href="#运行Docker镜像" class="headerlink" title="运行Docker镜像"></a>运行Docker镜像</h3><p>执行下面的命令来运行上一步构建的Docker镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 8080:8080 -t springio/docker</span><br></pre></td></tr></table></figure>
<p>如果不出意外，你将看到下面的输出内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::        (v1.5.2.RELEASE)</span><br><span class="line"></span><br><span class="line">2017-03-08 03:34:59.434  INFO 6 --- [           main] o.m.springboot.DockerApplication         : Starting DockerApplication v0.0.1-SNAPSHOT on 00eed53e6928 with PID 6 (/app.jar started by root in /)</span><br><span class="line">2017-03-08 03:34:59.445  INFO 6 --- [           main] o.m.springboot.DockerApplication         : No active profile set, falling back to default profiles: default</span><br><span class="line">2017-03-08 03:34:59.752  INFO 6 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@4b9af9a9: startup date [Wed Mar 08 03:34:59 GMT 2017]; root of context hierarchy</span><br><span class="line">2017-03-08 03:35:03.755  INFO 6 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2017-03-08 03:35:03.807  INFO 6 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat</span><br><span class="line">2017-03-08 03:35:03.821  INFO 6 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.11</span><br><span class="line">2017-03-08 03:35:04.042  INFO 6 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2017-03-08 03:35:04.043  INFO 6 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 4303 ms</span><br><span class="line">2017-03-08 03:35:04.441  INFO 6 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: &apos;dispatcherServlet&apos; to [/]</span><br><span class="line">2017-03-08 03:35:04.455  INFO 6 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]</span><br><span class="line">2017-03-08 03:35:04.457  INFO 6 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]</span><br><span class="line">2017-03-08 03:35:04.468  INFO 6 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]</span><br><span class="line">2017-03-08 03:35:04.468  INFO 6 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: &apos;requestContextFilter&apos; to: [/*]</span><br><span class="line">2017-03-08 03:35:05.110  INFO 6 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@4b9af9a9: startup date [Wed Mar 08 03:34:59 GMT 2017]; root of context hierarchy</span><br><span class="line">2017-03-08 03:35:05.390  INFO 6 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/]&#125;&quot; onto public java.lang.String org.matrixstudio.springboot.DockerApplication.home()</span><br><span class="line">2017-03-08 03:35:05.402  INFO 6 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)</span><br><span class="line">2017-03-08 03:35:05.404  INFO 6 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)</span><br><span class="line">2017-03-08 03:35:05.512  INFO 6 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span><br><span class="line">2017-03-08 03:35:05.512  INFO 6 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span><br><span class="line">2017-03-08 03:35:05.639  INFO 6 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span><br><span class="line">2017-03-08 03:35:06.019  INFO 6 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span><br><span class="line">2017-03-08 03:35:06.168  INFO 6 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)</span><br><span class="line">2017-03-08 03:35:06.183  INFO 6 --- [           main] o.m.springboot.DockerApplication         : Started DockerApplication in 7.893 seconds (JVM running for 8.743)</span><br><span class="line">2017-03-08 03:35:56.728  INFO 6 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;</span><br><span class="line">2017-03-08 03:35:56.728  INFO 6 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started</span><br><span class="line">2017-03-08 03:35:56.774  INFO 6 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 43 ms</span><br></pre></td></tr></table></figure>
<p>执行以下命令，查看正在运行的Docker容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure>
<p>可以看到已经有一个Docker容器在运行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">00eed53e6928        springio/docker     &quot;sh -c &apos;java $JAVA...&quot;   About a minute ago   Up About a minute   0.0.0.0:8080-&gt;8080/tcp   fervent_leavitt</span><br></pre></td></tr></table></figure>
<p>现在输入<code>http://localhost:8080</code>可以查看到“Hello Docker World”结果。</p>
<p>如果要停止容器，可以执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker stop 00e</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8新特性（一）：Lambda表达式</title>
    <url>/java/java8-lambda-expression.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/java8-logo.jpeg"></p>
<p>Java 8发布距今都两年了，实际开发用的jdk版本也是1.8，但一直没怎么关注过它的新特性，碰巧最近老系统重构工作，就一并学习了，整理一下分享给大家。</p>
<p>这个系列一共有四篇文章，分别为：Lambda表达式、Stream API、新的时间和日期API、Optional类，本篇是第一篇——Lambda表达式。</p>
<a id="more"></a>
<h2 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h2><p>学Lambda表达式之前，我们先了解一个概念：行为参数化。</p>
<p>简单来说，行为参数化就是预先定义一个代码块而不去执行它，把它当做参数传递给另一个方法，这样，这个方法的行为就被这段代码块参数化了。</p>
<p>听起来有些抽象对吧？我们通过几段代码给大家演示一下。假设我们正在开发一个图书管理系统，需求是要对图书的作者进行过滤，筛选出指定作者的书籍。比较常见的做法就是写一个方法，把作者当成方法的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">filterByAuthor</span><span class="params">(List&lt;Book&gt; books, String author)</span> </span>&#123;</span><br><span class="line">	List&lt;Book&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">		<span class="keyword">if</span> (author.equals(book.getAuthor())) &#123;</span><br><span class="line">			result.add(book);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需求变了，要按照出版社过滤，再写一个方法过滤出版社：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">filterByPublisher</span><span class="params">(List&lt;Book&gt; books, String publisher)</span> </span>&#123;</span><br><span class="line">	List&lt;Book&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">		<span class="keyword">if</span> (publisher.equals(book.getPublisher())) &#123;</span><br><span class="line">			result.add(book);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法除了名称之外，内部的实现逻辑几乎一模一样，唯一的区别就是<code>if</code>判断条件，前者判断的是作者，后者判断的是出版社。如果现在需求又变了，需要按照图书的售价过滤，是不是需要再次将上面的方法复制一遍，将<code>if</code>判断条件改为售价？太Low了，这种做法违背了DRY（Don’t Repeat Yourself，不要重复自己）原则，而且不利于后期维护，如果需要改变方法内部遍历方式来提高性能，意味着每个<code>filterByXxx()</code>方法都需要修改，工作量太大。</p>
<p>比较好的办法就是吧过滤的条件抽象出来，过滤的条件无非就是图书的某些属性（比如价格、出版社、出版日期、作者等），可以通过一个接口来申明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookPredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BookPredicate</code>接口只有一个抽象方法<code>test()</code>，该方法接受一个<code>Book</code>类型参数，返回一个<code>boolean</code>值，可以用它来表示图书的不同过滤条件。</p>
<p>接下来我们对之前的过滤方法进行重构，将<code>filterByXxx()</code>方法的第二个参数换成上面定义的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">filter</span><span class="params">(List&lt;Book&gt; books, BookPredicate bookPredicate)</span> </span>&#123;</span><br><span class="line">    List&lt;Book&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bookPredicate.test(book)) &#123;</span><br><span class="line">			result.add(book);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将过滤的条件换成<code>BookPredicate</code>的实现类，这里采用了内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据作者过滤</span></span><br><span class="line"><span class="keyword">final</span> String author = <span class="string">"张三"</span>;</span><br><span class="line">List&lt;Book&gt; result = filter(books, <span class="keyword">new</span> BookPredicate() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author.equals(book.getAuthor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据图书价格过滤</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> price = <span class="number">100.00</span>D;</span><br><span class="line">List&lt;Book&gt; result = filter(books, <span class="keyword">new</span> BookPredicate() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price &gt; book.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的过程中，我们把所有<code>filterByXXX()</code>方法统一替换成<code>filter()</code>这一个方法，<code>filter()</code>方法的第二个参数换成<code>BookPredicate</code>接口，因此如果要改变过滤条件，只需要为<code>BookPredicate</code>接口写一个新的实现类即可。这种方式，就叫行为参数化，也就是说我们把图书的过滤行为（<code>BookPredicate</code>接口的实现类）当成了<code>filter()</code>方法的参数。现在可以把其他的<code>filterByXXX()</code>方法删掉了，只保留<code>filter()</code>方法，即便是后期要修改方法内部的集合遍历方式来优化性能，也只改这一个方法。</p>
<p>不过，<code>BookPredicate</code>接口并不完美，它只是针对图书的过滤，如果需要对其他对象集合排序（如：用户）就不行了，继续改造使其支持泛型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以把<code>filter()</code>方法用在任何对象的过滤中。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>虽然我们对<code>filter()</code>方法进行重构，并抽象了<code>Predicate</code>接口作为过滤的条件，但实际上还需要编写很多内部类来实现<code>Predicate</code>接口。使用内部类的方式实现<code>Predicate</code>接口有很多缺点：首先是代码显得很臃肿，可读性差；其次，如果某个局部变量被内部类使用，这个变量必须使用<code>final</code>关键字修饰。在Java 8中，使用Lambda表达式可以对内部类进一步简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据作者过滤</span></span><br><span class="line">List&lt;Book&gt; result = filter(books, book -&gt; <span class="string">"张三"</span>.equals(book.getAuthor()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据图书价格过滤</span></span><br><span class="line">List&lt;Book&gt; result = filter(books, book -&gt; <span class="number">100</span> &gt; book.getPrice());</span><br></pre></td></tr></table></figure>
<p>使用Lambda仅用一行代码就对内部类进行了转化，而且代码变得更加清晰可读。其中<code>book -&gt; &quot;张三&quot;.equals(book.getAuthor())</code>和<code>book -&gt; 100 &gt; book.getPrice()</code>就是我们接下来要研究的Lambda表达式。</p>
<h3 id="Lambda表达式是什么"><a href="#Lambda表达式是什么" class="headerlink" title="Lambda表达式是什么"></a>Lambda表达式是什么</h3><p>Lambda表达式（lambda expression）是一个匿名函数，由数学中的λ演算而得名。在Java 8中可以把Lambda表达式理解为匿名函数，它没有名称，但是有参数列表、函数主体、返回类型等。</p>
<p>Lambda表达式的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用Lambda表达式？前面你也看到了，在Java中使用内部类显得十分冗长，要编写很多样板代码，Lambda表达式就是为了简化这些步骤出现的，它使代码变得清晰易懂。</p>
<h3 id="如何使用Lambda表达式"><a href="#如何使用Lambda表达式" class="headerlink" title="如何使用Lambda表达式"></a>如何使用Lambda表达式</h3><p>Lambda表达式是为了简化内部类的，你可以把它当成是内部类的一种简写方式，只要是有内部类的代码块，都可以转化成Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator排序</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">list.sort(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式简化</span></span><br><span class="line">list.sort((o1, o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runnable代码块</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式简化</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello Man!"</span>));</span><br></pre></td></tr></table></figure>
<p>可以看出，只要是内部类的代码块，就可以使用Lambda表达式简化，并且简化后的代码清晰易懂。甚至，<code>Comparator</code>排序的Lambda表达式还可以进一步简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(Integer::compareTo);</span><br></pre></td></tr></table></figure>
<p>这种写法被称为<strong>方法引用</strong>，方法引用是Lambda表达式的进一步简化。如果你的Lambda表达式只是调用这个方法，最好使用名称调用，而不是描述如何调用，这样可以提高代码的可读性。</p>
<p>方法引用使用<code>::</code>分隔符，分隔符的前半部分表示引用类型，后面半部分表示引用的方法名称。例如：<code>Integer::compareTo</code>表示引用类型为<code>Integer</code>，引用名称为<code>compareTo</code>的方法。</p>
<p>类似使用方法引用的例子还有打印集合中的元素到控制台中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>如果你查看<code>Runnable</code>接口源代码，你会发现该接口上有一个<code>@FunctionalInterface</code>的注解，这是Java 8中添加的新注解，用于表示<strong>函数式接口</strong>。</p>
<p>在Java 8中，把那些仅有一个抽象方法的接口称为函数式接口。如果一个接口被<code>@FunctionalInterface</code>注解标注，表示这个接口被设计成函数式接口，只能有一个抽象方法，如果你添加多个抽象方法，编译时会提示“Multiple non-overriding abstract methods found in interface XXX”之类的错误。</p>
<p>函数式接口能做什么？简单来说，你可以将整个Lambda表达式作为接口的实现类。</p>
<p>除了<code>Runnable</code>之外，Java 8中内置了许多函数式接口供开发者使用，这些接口位于<code>java.util.function</code>包中，上面实例中最后使用的<code>Predicate</code>接口，其实已经被包含在这个包内，他们分别为<code>Predicate</code>、<code>Consumer</code>和<code>Function</code>。</p>
<p>由于我们已经在之前的图书过滤的例子中介绍了<code>Predicate</code>的用法，所以接下来主要介绍<code>Consumer</code>和<code>Function</code>的用法。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a><code>Consumer</code></h3><p><code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫<code>accept()</code>的抽象方法，它接受泛型<code>T</code>的对象，没有返回（<code>void</code>）。如果你需要访问类型<code>T</code>的对象，并对其执行某些操作，就可以使用这个接口。比如，你可以用它来创建一个<code>forEach()</code>方法，接受一个集合，并对集合中每个元素执行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t: list)&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>);</span><br><span class="line">    forEach(list, str -&gt; System.out.println(str));</span><br><span class="line">    <span class="comment">// 也可以写成</span></span><br><span class="line">    forEach(list, System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a><code>Function</code></h3><p><code>java.util.function.Function&lt;T, R&gt;</code>接口定义了一个叫作<code>apply()</code>的方法，它接受一个泛型<code>T</code>的对象，并返回一个泛型<code>R</code>的对象。可以看出这个接口主要用于将一个对象转化成另一个类型的对象。比如，比如要提取一个图书集合中所有的作者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T, R&gt; f)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T s: list)&#123;</span><br><span class="line">        result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Book&gt; books = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Book(<span class="string">"张三"</span>, <span class="number">99.00</span>D),</span><br><span class="line">        <span class="keyword">new</span> Book(<span class="string">"李四"</span>, <span class="number">59.00</span>D),</span><br><span class="line">        <span class="keyword">new</span> Book(<span class="string">"王老五"</span>, <span class="number">59.00</span>D)</span><br><span class="line">    );</span><br><span class="line">    List&lt;String&gt; authors = map(books, book -&gt; book.getAuthor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是对Lambda表达式有初步认识了？现在你可以用Lambda表达式重构你的代码，看看重构后有没有变得简洁。下一篇将介绍流式数据处理——Stream API。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8新特性（四）：新的时间和日期API</title>
    <url>/java/java8-newtime-api.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/java8-logo.jpeg"></p>
<p>本片是Java 8新特性系列的最后一篇，主要介绍新增加的时间和日期API，它们被包含在<code>java.time</code>包中。借助新的时间和日期API可以以更简洁的方法处理时间和日期。</p>
<a id="more"></a>
<p>在介绍本篇文章内容之前，我们先来讨论Java 8为什么要引入新的日期API，与之前的时间和日期处理方式有什么不同？</p>
<p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p>
<ol>
<li>Java的<code>java.util.Date</code>和<code>java.util.Calendar</code>类易用性差，不支持时区，而且他们都不是线程安全的；</li>
<li>用于格式化日期的类<code>DateFormat</code>被放在<code>java.text</code>包中，它是一个抽象类，所以我们需要实例化一个<code>SimpleDateFormat</code>对象来处理日期格式化，并且<code>DateFormat</code>也是非线程安全，你得把它用<code>ThreadLocal</code>包起来才能在多线程中使用。</li>
<li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从<code>Calendar</code>中获取的月份需要加一才能表示当前月份。</li>
</ol>
<p>由于以上这些问题，出现了一些三方的日期处理框架，例如Joda-Time，date4j等开源项目。但是，Java需要一套标准的用于处理时间和日期的框架，于是Java 8中引入了新的日期API。新的日期API是<a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">JSR-310</a>规范的实现，Joda-Time框架的作者正是JSR-310的规范的倡导者，所以能从Java 8的日期API中看到很多Joda-Time的特性。</p>
<h2 id="Java-8日期-时间类"><a href="#Java-8日期-时间类" class="headerlink" title="Java 8日期/时间类"></a>Java 8日期/时间类</h2><p>Java 8的日期和时间类包含<code>LocalDate</code>、<code>LocalTime</code>、<code>Instant</code>、<code>Duration</code>以及<code>Period</code>，这些类都包含在<code>java.time</code>包中，下面我们看看这些类的用法。</p>
<h3 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a><code>LocalDate</code>和<code>LocalTime</code></h3><p><code>LocalDate</code>类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过<code>LocalDate</code>的静态方法<code>of()</code>创建一个实例，<code>LocalDate</code>也包含一些方法用来获取年份，月份，天，星期几等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">4</span>);     <span class="comment">// 初始化一个日期：2017-01-04</span></span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();                     <span class="comment">// 年份：2017</span></span><br><span class="line">Month month = localDate.getMonth();                 <span class="comment">// 月份：JANUARY</span></span><br><span class="line"><span class="keyword">int</span> dayOfMonth = localDate.getDayOfMonth();         <span class="comment">// 月份中的第几天：4</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();     <span class="comment">// 一周的第几天：WEDNESDAY</span></span><br><span class="line"><span class="keyword">int</span> length = localDate.lengthOfMonth();             <span class="comment">// 月份的天数：31</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = localDate.isLeapYear();          <span class="comment">// 是否为闰年：false</span></span><br></pre></td></tr></table></figure>
<p>也可以调用静态方法<code>now()</code>来获取当前日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();</span><br></pre></td></tr></table></figure>
<p><code>LocalTime</code>和<code>LocalDate</code>类似，他们之间的区别在于<code>LocalDate</code>不包含具体时间，而<code>LocalTime</code>包含具体时间，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);     <span class="comment">// 初始化一个时间：17:23:52</span></span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();                     <span class="comment">// 时：17</span></span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();                 <span class="comment">// 分：23</span></span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();                 <span class="comment">// 秒：52</span></span><br></pre></td></tr></table></figure>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a><code>LocalDateTime</code></h3><p><code>LocalDateTime</code>类是<code>LocalDate</code>和<code>LocalTime</code>的结合体，可以通过<code>of()</code>方法直接创建，也可以调用<code>LocalDate</code>的<code>atTime()</code>方法或<code>LocalTime</code>的<code>atDate()</code>方法将<code>LocalDate</code>或<code>LocalTime</code>合并成一个<code>LocalDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>也提供用于向<code>LocalDate</code>和<code>LocalTime</code>的转化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = ldt1.toLocalDate();</span><br><span class="line">LocalTime time = ldt1.toLocalTime();</span><br></pre></td></tr></table></figure>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a><code>Instant</code></h3><p><code>Instant</code>用于表示一个时间戳，它与我们常使用的<code>System.currentTimeMillis()</code>有些类似，不过<code>Instant</code>可以精确到纳秒（Nano-Second），<code>System.currentTimeMillis()</code>方法只精确到毫秒（Milli-Second）。如果查看<code>Instant</code>源码，发现它的内部使用了两个常量，<code>seconds</code>表示从1970-01-01 00:00:00开始到现在的秒数，<code>nanos</code>表示纳秒部分（<code>nanos</code>的值不会超过<code>999,999,999</code>）。<code>Instant</code>除了使用<code>now()</code>方法创建外，还可以通过<code>ofEpochSecond</code>方法创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);</span><br></pre></td></tr></table></figure>
<p><code>ofEpochSecond()</code>方法的第一个参数为秒，第二个参数为纳秒，上面的代码表示从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻，控制台上的输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1970-01-01T00:02:00.000100Z</span><br></pre></td></tr></table></figure>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a><code>Duration</code></h3><p><code>Duration</code>的内部实现与<code>Instant</code>类似，也是包含两部分：<code>seconds</code>表示秒，<code>nanos</code>表示纳秒。两者的区别是<code>Instant</code>用于表示一个时间戳（或者说是一个时间点），而<code>Duration</code>表示一个时间段，所以<code>Duration</code>类中不包含<code>now()</code>静态方法。可以通过<code>Duration.between()</code>方法创建<code>Duration</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);    <span class="comment">// 2017-01-05 10:07:00</span></span><br><span class="line">LocalDateTime to = LocalDateTime.of(<span class="number">2017</span>, Month.FEBRUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);     <span class="comment">// 2017-02-05 10:07:00</span></span><br><span class="line">Duration duration = Duration.between(from, to);     <span class="comment">// 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();              <span class="comment">// 这段时间的总天数</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();            <span class="comment">// 这段时间的小时数</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();        <span class="comment">// 这段时间的分钟数</span></span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();       <span class="comment">// 这段时间的秒数</span></span><br><span class="line"><span class="keyword">long</span> milliSeconds = duration.toMillis();    <span class="comment">// 这段时间的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> nanoSeconds = duration.toNanos();      <span class="comment">// 这段时间的纳秒数</span></span><br></pre></td></tr></table></figure>
<p><code>Duration</code>对象还可以通过<code>of()</code>方法创建，该方法接受一个时间段长度，和一个时间单位作为参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration duration1 = Duration.of(<span class="number">5</span>, ChronoUnit.DAYS);       <span class="comment">// 5天</span></span><br><span class="line">Duration duration2 = Duration.of(<span class="number">1000</span>, ChronoUnit.MILLIS);  <span class="comment">// 1000毫秒</span></span><br></pre></td></tr></table></figure>
<h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a><code>Period</code></h3><p><code>Period</code>在概念上和<code>Duration</code>类似，区别在于<code>Period</code>是以年月日来衡量一个时间段，比如2年3个月6天：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Period period = Period.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p><code>Period</code>对象也可以通过<code>between()</code>方法创建，值得注意的是，由于<code>Period</code>是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2017-01-05 到 2017-02-05 这段时间</span></span><br><span class="line">Period period = Period.between(</span><br><span class="line">                LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">                LocalDate.of(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<h2 id="日期的操作和格式化"><a href="#日期的操作和格式化" class="headerlink" title="日期的操作和格式化"></a>日期的操作和格式化</h2><h3 id="增加和减少日期"><a href="#增加和减少日期" class="headerlink" title="增加和减少日期"></a>增加和减少日期</h3><p>Java 8中的日期/时间类都是不可变的（用<code>final</code>修饰），这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);          <span class="comment">// 2017-01-05</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = date.withYear(<span class="number">2016</span>);              <span class="comment">// 修改为 2016-01-05</span></span><br><span class="line">LocalDate date2 = date.withMonth(<span class="number">2</span>);                <span class="comment">// 修改为 2017-02-05</span></span><br><span class="line">LocalDate date3 = date.withDayOfMonth(<span class="number">1</span>);           <span class="comment">// 修改为 2017-01-01</span></span><br><span class="line"></span><br><span class="line">LocalDate date4 = date.plusYears(<span class="number">1</span>);                <span class="comment">// 增加一年 2018-01-05</span></span><br><span class="line">LocalDate date5 = date.minusMonths(<span class="number">2</span>);              <span class="comment">// 减少两个月 2016-11-05</span></span><br><span class="line">LocalDate date6 = date.plus(<span class="number">5</span>, ChronoUnit.DAYS);    <span class="comment">// 增加5天 2017-01-10</span></span><br></pre></td></tr></table></figure>
<p>上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用<code>with()</code>方法的另一个重载方法，它接收一个<code>TemporalAdjuster</code>参数，可以使我们更加灵活的调整日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      <span class="comment">// 返回下一个距离当前时间最近的星期日</span></span><br><span class="line">LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   <span class="comment">// 返回本月最后一个星期六</span></span><br></pre></td></tr></table></figure>
<p>要使上面的代码正确编译，你需要使用静态导入<code>TemporalAdjusters</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</span><br></pre></td></tr></table></figure>
<p><code>TemporalAdjusters</code>类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dayOfWeekInMonth</code></td>
<td>返回同一个月中每周的第几天</td>
</tr>
<tr>
<td><code>firstDayOfMonth</code></td>
<td>返回当月的第一天</td>
</tr>
<tr>
<td><code>firstDayOfNextMonth</code></td>
<td>返回下月的第一天</td>
</tr>
<tr>
<td><code>firstDayOfNextYear</code></td>
<td>返回下一年的第一天</td>
</tr>
<tr>
<td><code>firstDayOfYear</code></td>
<td>返回本年的第一天</td>
</tr>
<tr>
<td><code>firstInMonth</code></td>
<td>返回同一个月中第一个星期几</td>
</tr>
<tr>
<td><code>lastDayOfMonth</code></td>
<td>返回当月的最后一天</td>
</tr>
<tr>
<td><code>lastDayOfNextMonth</code></td>
<td>返回下月的最后一天</td>
</tr>
<tr>
<td><code>lastDayOfNextYear</code></td>
<td>返回下一年的最后一天</td>
</tr>
<tr>
<td><code>lastDayOfYear</code></td>
<td>返回本年的最后一天</td>
</tr>
<tr>
<td><code>lastInMonth</code></td>
<td>返回同一个月中最后一个星期几</td>
</tr>
<tr>
<td><code>next / previous</code></td>
<td>返回后一个/前一个给定的星期几</td>
</tr>
<tr>
<td><code>nextOrSame / previousOrSame</code></td>
<td>返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td>
</tr>
</tbody>
</table>
<p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的<code>TemporalAdjuster</code>接口的实现，<code>TemporalAdjuster</code>也是一个函数式接口，所以我们可以使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">date.with(temporal -&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前日期</span></span><br><span class="line">    DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下，每次增加一天</span></span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期五，增加三天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期六，增加两天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, ChronoUnit.DAYS);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><p>新的日期API中提供了一个<code>DateTimeFormatter</code>类用于处理日期格式化操作，它被包含在<code>java.time.format</code>包中，Java 8的日期类有一个<code>format()</code>方法用于将日期格式化为字符串，该方法接收一个<code>DateTimeFormatter</code>类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">// 20170105</span></span><br><span class="line">String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    <span class="comment">// 2017-01-05</span></span><br><span class="line">String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    <span class="comment">// 14:20:16.998</span></span><br><span class="line">String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));   <span class="comment">// 2017-01-05</span></span><br><span class="line">String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"今天是：YYYY年 MMMM DD日 E"</span>, Locale.CHINESE)); <span class="comment">// 今天是：2017年 一月 05日 星期四</span></span><br></pre></td></tr></table></figure>
<p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strDate6 = <span class="string">"2017-01-05"</span>;</span><br><span class="line">String strDate7 = <span class="string">"2017-01-05 12:30:05"</span>;</span><br><span class="line"></span><br><span class="line">LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>Java 8中的时区操作被很大程度上简化了，新的时区类<code>java.time.ZoneId</code>是原有的<code>java.util.TimeZone</code>类的替代品。<code>ZoneId</code>对象可以通过<code>ZoneId.of()</code>方法创建，也可以通过<code>ZoneId.systemDefault()</code>获取系统默认时区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneId shanghaiZoneId = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">ZoneId systemZoneId = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure>
<p><code>of()</code>方法接收一个“区域/城市”的字符串作为参数，你可以通过<code>getAvailableZoneIds()</code>方法获取所有合法的“区域/城市”字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br></pre></td></tr></table></figure>
<p>对于老的时区类<code>TimeZone</code>，Java 8也提供了转化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure>
<p>有了<code>ZoneId</code>，我们就可以将一个<code>LocalDate</code>、<code>LocalTime</code>或<code>LocalDateTime</code>对象转化为<code>ZonedDateTime</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);</span><br></pre></td></tr></table></figure>
<p>将<code>zonedDateTime</code>打印到控制台为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2017-01-05T15:26:56.147+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<p><code>ZonedDateTime</code>对象由两部分构成，<code>LocalDateTime</code>和<code>ZoneId</code>，其中<code>2017-01-05T15:26:56.147</code>部分为<code>LocalDateTime</code>，<code>+08:00[Asia/Shanghai]</code>部分为<code>ZoneId</code>。</p>
<p>另一种表示时区的方式是使用<code>ZoneOffset</code>，它是以当前时间和<strong>世界标准时间（UTC）/格林威治时间（GMT）</strong>的偏差来计算，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+09:00"</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br></pre></td></tr></table></figure>
<h2 id="其他历法"><a href="#其他历法" class="headerlink" title="其他历法"></a>其他历法</h2><p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p>
<p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p>
<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>
<p>每个日期类都继承<code>ChronoLocalDate</code>类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。</p>
<p>这些不同的历法也可以用于向公历转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">JapaneseDate jpDate = JapaneseDate.from(date);</span><br></pre></td></tr></table></figure>
<p>由于它们都继承<code>ChronoLocalDate</code>类，所以在不知道具体历法情况下，可以通过<code>ChronoLocalDate</code>类操作日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);</span><br><span class="line">ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();</span><br></pre></td></tr></table></figure>
<p>我们在开发过程中应该尽量避免使用<code>ChronoLocalDate</code>，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p>
<p>在实际开发过程中建议使用<code>LocalDate</code>，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用<code>ChronoLocalDate</code>类。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8新特性（三）：Optional类</title>
    <url>/java/java8-optional.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/java8-logo.jpeg"></p>
<p>在上一篇介绍Stream流式数据处理的文章中提到了<code>Optional</code>类，这是Java 8新增的一个类，用以解决程序中常见的<code>NullPointerException</code>异常问题。本篇文章将详细介绍<code>Optional</code>类，以及如何用它消除代码中的<code>null</code>检查。</p>
<a id="more"></a>
<h2 id="避免使用null检查"><a href="#避免使用null检查" class="headerlink" title="避免使用null检查"></a>避免使用<code>null</code>检查</h2><p>作为Java开发人员，几乎所有人都遇到过<code>NullPointerException</code>异常，大多数人遇到<code>NullPointerException</code>异常时都会在异常出现的地方加上<code>if</code>代码块来判断值不为空，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindUserToRole</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String roleId = user.getRoleId();</span><br><span class="line">        <span class="keyword">if</span> (roleId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Role role = roleDao.findOne(roleId);</span><br><span class="line">            <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">                role.setUserId(user.getUserId());</span><br><span class="line">                roleDao.save(role);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是比较普遍的做法，为了避免出现<code>NullPointerException</code>异常，手动对可能为<code>null</code>值进行了处理，只不过代码可读性就没那么好，业务逻辑都被淹没在<code>if</code>逻辑判断中，重构一下看起来会好一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindUserToRole</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String roleId = user.getRoleId();</span><br><span class="line">    <span class="keyword">if</span> (roleId == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Role = roleDao.findOne(roleId);</span><br><span class="line">    <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">        role.setUserId(user.getUserId());</span><br><span class="line">        roleDao.save(role);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码避免了深层的<code>if</code>语句嵌套，但本质上是一样的，方法内有三个不同的返回点，出错后调试也不容易，你都不知道是那个值导致了<code>NullPointerException</code>异常。</p>
<p>基于上面的原因，Java 8中引入了一个新的类<code>Optional</code>，用以避免使用<code>null</code>值引发的种种问题。</p>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a><code>Optional</code>类</h2><p><code>java.util.Optional&lt;T&gt;</code>类是一个封装了<code>Optional</code>值的容器对象，<code>Optional</code>值可以为<code>null</code>，如果值存在，调用<code>isPresent()</code>方法返回<code>true</code>，调用<code>get()</code>方法可以获取值。</p>
<h3 id="创建Optional对象"><a href="#创建Optional对象" class="headerlink" title="创建Optional对象"></a>创建<code>Optional</code>对象</h3><p><code>Optional</code>类提供类三个方法用于实例化一个<code>Optional</code>对象，它们分别为<code>empty()</code>、<code>of()</code>、<code>ofNullable()</code>，这三个方法都是静态方法，可以直接调用。</p>
<hr>
<p><code>empty()</code>方法用于创建一个没有值的<code>Optional</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; emptyOpt = Optional.empty();</span><br></pre></td></tr></table></figure>
<p><code>empty()</code>方法创建的对象没有值，如果对<code>emptyOpt</code>变量调用<code>isPresent()</code>方法会返回<code>false</code>，调用<code>get()</code>方法抛出<code>NullPointerException</code>异常。</p>
<hr>
<p><code>of()</code>方法使用一个非空的值创建<code>Optional</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Hello World"</span>;</span><br><span class="line">Optional&lt;String&gt; notNullOpt = Optional.of(str);</span><br></pre></td></tr></table></figure>
<hr>
<p><code>ofNullable()</code>方法接收一个可以为<code>null</code>的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; nullableOpt = Optional.ofNullable(str);</span><br></pre></td></tr></table></figure>
<p>如果<code>str</code>的值为<code>null</code>，得到的<code>nullableOpt</code>是一个没有值的<code>Optional</code>对象。</p>
<h3 id="提取Optional对象中的值"><a href="#提取Optional对象中的值" class="headerlink" title="提取Optional对象中的值"></a>提取<code>Optional</code>对象中的值</h3><p>如果我们要获取<code>User</code>对象中的<code>roleId</code>属性值，常见的方式是直接获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String roleId = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    roleId = user.getRoleId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Optional</code>中提供的<code>map()</code>方法可以以更简单的方式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line">Optional&lt;String&gt; roleIdOpt = userOpt.map(User::getRoleId);</span><br></pre></td></tr></table></figure>
<p><code>map()</code>方法与Stream API中的<code>map()</code>一样，类似于映射操作，将原始类型映射为一个新的类型。</p>
<h3 id="使用orElse-方法获取值"><a href="#使用orElse-方法获取值" class="headerlink" title="使用orElse()方法获取值"></a>使用<code>orElse()</code>方法获取值</h3><p><code>Optional</code>类还包含其他方法用于获取值，这些方法分别为：</p>
<ul>
<li><code>orElse()</code>：如果有值就返回，否则返回一个给定的值作为默认值；</li>
<li><code>orElseGet()</code>：与<code>orElse()</code>方法作用类似，区别在于生成默认值的方式不同。该方法接受一个<code>Supplier&lt;? extends T&gt;</code>函数式接口参数，用于生成默认值；</li>
<li><code>orElseThrow()</code>：与前面介绍的<code>get()</code>方法类似，当值为<code>null</code>时调用这两个方法都会抛出<code>NullPointerException</code>异常，区别在于该方法可以指定抛出的异常类型。</li>
</ul>
<p>下面来看看这三个方法的具体用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Hello World"</span>;</span><br><span class="line">Optional&lt;String&gt; strOpt = Optional.of(str);</span><br><span class="line">String orElseResult = strOpt.orElse(<span class="string">"Hello Shanghai"</span>);</span><br><span class="line">String orElseGet = strOpt.orElseGet(() -&gt; <span class="string">"Hello Shanghai"</span>);</span><br><span class="line">String orElseThrow = strOpt.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Argument 'str' cannot be null or blank."</span>));</span><br></pre></td></tr></table></figure>
<p>此外，<code>Optional</code>类还提供了一个<code>ifPresent()</code>方法，该方法接收一个<code>Consumer&lt;? super T&gt;</code>函数式接口，可以对值进行一些操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; strOpt = Optional.of(<span class="string">"Hello World"</span>);</span><br><span class="line">strOpt.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="使用filter-方法过滤"><a href="#使用filter-方法过滤" class="headerlink" title="使用filter()方法过滤"></a>使用<code>filter()</code>方法过滤</h3><p><code>filter()</code>方法可用于判断<code>Optional</code>对象是否满足给定条件，一般用于条件过滤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"lw900925@163.com"</span>);</span><br><span class="line">optional = optional.filter(str -&gt; str.contains(<span class="string">"164"</span>));</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，如果<code>filter()</code>方法中的Lambda表达式成立，<code>filter()</code>方法会返回当前<code>Optional</code>对象值，否则，返回一个值为空的<code>Optional</code>对象。</p>
<h2 id="如何正确使用Optional"><a href="#如何正确使用Optional" class="headerlink" title="如何正确使用Optional"></a>如何正确使用<code>Optional</code></h2><p>我发现好像很多人（别说还真的很多）没有掌握<code>Optional</code>的正确使用方法，比如我一个同事喜欢写这样的<code>Optional</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">if</span> (userOpt.isPresent()) &#123;</span><br><span class="line">    User user = userOpt.get();</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说实话，这样的写法跟传统的<code>if</code>语句判断空值没有任何区别，没有起到<code>Optional</code>的正真作用（中枪的同学举手）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当我们从之前版本切换到Java 8的时候，不应该还按照以前的思维方式处理<code>null</code>值，Java 8提倡函数式编程，新增的许多API都可以用函数式编程表示，<code>Optional</code>类也是其中之一。这里有几条关于<code>Optional</code>使用的建议：</p>
<ol>
<li>尽量避免在程序中直接调用<code>Optional</code>对象的<code>get()</code>和<code>isPresent()</code>方法；</li>
<li>避免使用<code>Optional</code>类型声明实体类的属性；</li>
</ol>
<p>第一条建议中直接调用<code>get()</code>方法是很危险的做法，如果<code>Optional</code>的值为空，那么毫无疑问会抛出<code>NullPointerException</code>异常，而为了调用<code>get()</code>方法而使用<code>isPresent()</code>方法作为空值检查，这种做法与传统的用<code>if</code>语句块做空值检查没有任何区别。</p>
<p>第二条建议避免使用<code>Optional</code>作为实体类的属性，它在设计的时候就没有考虑过用来作为类的属性，可以查看<code>Optional</code>的源代码，你会发现它没有实现<code>java.io.Serializable</code>接口，也就是说如果你用到一些orm框架的二级缓存，使用<code>Optional</code>作为实体类的属性没法被序列化。</p>
<p>下面我们通过一些例子讲解<code>Optional</code>的正确用法：</p>
<h3 id="正确创建Optional对象"><a href="#正确创建Optional对象" class="headerlink" title="正确创建Optional对象"></a>正确创建<code>Optional</code>对象</h3><p>上面提到创建<code>Optional</code>对象有三个方法，<code>empty()</code>方法比较简单，没什么特别要说明的。主要是<code>of()</code>和<code>ofNullable()</code>方法。当你很确定一个对象不可能为<code>null</code>的时候，应该使用<code>of()</code>方法，否则，尽可能使用<code>ofNullable()</code>方法，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当Optional的值通过常量获得或者通过关键字new初始化，可以直接使用of()方法</span></span><br><span class="line">    Optional&lt;String&gt; strOpt = Optional.of(<span class="string">"Hello World"</span>);</span><br><span class="line">    Optional&lt;User&gt; userOpt = Optional.of(<span class="keyword">new</span> User());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法参数中role值不确定是否为null，使用ofNullable()方法创建</span></span><br><span class="line">    Optional&lt;Role&gt; roleOpt = Optional.ofNullable(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="orElse-方法的使用"><a href="#orElse-方法的使用" class="headerlink" title="orElse()方法的使用"></a><code>orElse()</code>方法的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> str != <span class="keyword">null</span> ? str : <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure>
<p>上面的代码表示判断字符串<code>str</code>是否为空，不为空就返回，否则，返回一个常量。使用<code>Optional</code>类可以表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> strOpt.orElse(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="简化if-else"><a href="#简化if-else" class="headerlink" title="简化if-else"></a>简化<code>if-else</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = ...</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String userName = user.getUserName();</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> userName.toUpperCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以简化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = ...</span><br><span class="line">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userOpt.map(User::getUserName)</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>再比如判断用户名不能重复的逻辑，根据用户名从数据库中查询一个用户，如果不为null就抛出异常告诉前端用户已存在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User existUser = userDAO.findById(user.getUsername());</span><br><span class="line"><span class="keyword">if</span> (existUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AppException(<span class="string">"用户名已存在"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = userDAO.findById(user.getId());</span><br><span class="line">Optional.ofNullable(user).ifPresent(it -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> AppException(<span class="string">"用户名已存在"</span>));</span><br></pre></td></tr></table></figure>
<p>总结一下，新的<code>Optional</code>类让我们可以以函数式编程的方式处理<code>null</code>值而不用嵌套很多<code>if-else</code>逻辑。下一篇文章将介绍Java 8中新添加的日期API。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8新特性（二）：Stream API</title>
    <url>/java/java8-stream-api.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/java8-logo.jpeg"></p>
<p>本篇介绍Java 8的另一个新特性——Stream API。新增的Stream API与<code>InputStream</code>和<code>OutputStream</code>是完全不同的概念，Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作。</p>
<p>Stream API配合Lambda表达式可以加大的简化代码，提升可读性。Stream API也支持并行操作（类似于Fork-Join），甚至不用手动编写多线程代码，Stream API已经帮我们做好了，并且能充分利用多核CPU的优势。借助Stream API和Lambda表达式，可以很容易的编写出高性能的并发处理程序。</p>
<a id="more"></a>
<h2 id="Stream-API简介"><a href="#Stream-API简介" class="headerlink" title="Stream API简介"></a>Stream API简介</h2><p>Stream API是Java 8中加入的一套新的API，主要用于处理集合操作，不过它的处理方式与传统的方式不同，称为“数据流处理”。流（Stream）类似于关系数据库的查询操作，是一种声明式操作。比如要从数据库中获取所有年龄大于20岁的用户的名称，并按照用户的创建时间进行排序，用一条SQL语句就可以搞定，不过使用Java程序实现就会显得有些繁琐，这时候可以使用流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames =</span><br><span class="line">        users.stream()</span><br><span class="line">        .filter(user -&gt; user.getAge() &gt; <span class="number">20</span>)</span><br><span class="line">        .sorted(comparing(User::getCreationDate))</span><br><span class="line">        .map(User::getUserName)</span><br><span class="line">        .collect(toList());</span><br></pre></td></tr></table></figure>
<p>可以把流跟集合做一个比较。在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的<code>Iterator</code>，不过它可比<code>Iterator</code>强大多了。</p>
<p>流与集合另一个区别在于他们的遍历方式，遍历集合通常使用<code>for-each</code>方式，这种方式称为<strong>外部迭代</strong>，而流使用<strong>内部迭代</strong>方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部迭代</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部迭代</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在一些比较复杂的业务场景中，要对集合做一些统计、分组的操作，如果用传统的<code>for-each</code>方式遍历集合，每次只能处理一个元素，并且是按顺序处理，这种方法是极其低效的。你可能会想到用多线程去并行处理，但是编写多线程代码并非易事，容易出错并且维护困难。不过在Java 8之后，你可以使用Stream API来处理这些操作。</p>
<p>Stream API将迭代操作封装到了内部，它会自动的选择最优的迭代方式，并且使用并行方式处理时，将集合分成多段，每一段分别使用不同的线程处理，最后将处理结果合并输出，有点类似于Fork-Join操作。</p>
<p>需要注意的是，流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出<code>java.lang.IllegalStateException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">stream.forEach(System.out::println); <span class="comment">// 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭</span></span><br></pre></td></tr></table></figure>
<p>流通常由三部分构成：</p>
<ol>
<li>数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中<code>users.stream()</code>方法。</li>
<li>中间处理：中间处理包括对流中元素的一系列处理，如：过滤（<code>filter()</code>），映射（<code>map()</code>），排序（<code>sorted()</code>）。</li>
<li>终端处理：终端处理会生成结果，结果可以是任何不是流值，如<code>List&lt;String&gt;</code>；也可以不返回结果，如<code>stream.forEach(System.out::println)</code>就是将结果打印到控制台中，并没有返回。</li>
</ol>
<h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><p>创建流的方式有很多，具体可以划分为以下几种：</p>
<h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>使用静态方法<code>Stream.of()</code>创建流，该方法接收一个变长参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Stream&gt; stream = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用静态方法<code>Stream.empty()</code>创建一个空的流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Stream&gt; stream = Stream.empty();</span><br></pre></td></tr></table></figure>
<h3 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h3><p>使用静态方法<code>Arrays.stream()</code>从数组创建一个流，该方法接收一个数组参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>&#125;;</span><br><span class="line">Stream&lt;Stream&gt; stream = Arrays.stream(strs);</span><br></pre></td></tr></table></figure>
<h3 id="通过文件生成流"><a href="#通过文件生成流" class="headerlink" title="通过文件生成流"></a>通过文件生成流</h3><p>使用<code>java.nio.file.Files</code>类中的很多静态方法都可以获取流，比如<code>Files.lines()</code>方法，该方法接收一个<code>java.nio.file.Path</code>对象，返回一个由文件行构成的字符串流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Files.lines(Paths.get(<span class="string">"text.txt"</span>), Charset.defaultCharset());</span><br></pre></td></tr></table></figure>
<h3 id="通过函数创建流"><a href="#通过函数创建流" class="headerlink" title="通过函数创建流"></a>通过函数创建流</h3><p><code>java.util.stream.Stream</code>中有两个静态方法用于从函数生成流，他们分别是<code>Stream.generate()</code>和<code>Stream.iterate()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iteartor</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">51</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate</span></span><br><span class="line">Stream.generate(() -&gt; <span class="string">"Hello Man!"</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>第一个方法会打印100以内的所有偶数，第二个方法打印10个<code>Hello Man!</code>。需要注意的是，这两个方法生成的流都是无限流，没有固定大小，可以无穷的计算下去，在上面的代码中我们使用了<code>limit()</code>来避免打印无穷个值。</p>
<p>一般来说，<code>iterate()</code>用于生成一系列值，比如生成以当前时间开始之后的10天的日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(LocalDate.now(), date -&gt; date.plusDays(<span class="number">1</span>)).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><code>generate()</code>方法用于生成一些随机数，比如生成10个UUID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(() -&gt; UUID.randomUUID().toString()).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h2><p><code>Stream</code>接口中包含许多对流操作的方法，这些方法分别为：</p>
<ul>
<li><code>filter()</code>：对流的元素过滤</li>
<li><code>map()</code>：将流的元素映射成另一个类型</li>
<li><code>distinct()</code>：去除流中重复的元素</li>
<li><code>sorted()</code>：对流的元素排序</li>
<li><code>forEach()</code>：对流中的每个元素执行某个操作</li>
<li><code>peek()</code>：与<code>forEach()</code>方法效果类似，不同的是，该方法会返回一个新的流，而<code>forEach()</code>无返回</li>
<li><code>limit()</code>：截取流中前面几个元素</li>
<li><code>skip()</code>：跳过流中前面几个元素</li>
<li><code>toArray()</code>：将流转换为数组</li>
<li><code>reduce()</code>：对流中的元素归约操作，将每个元素合起来形成一个新的值</li>
<li><code>collect()</code>：对流的汇总操作，比如输出成<code>List</code>集合</li>
<li><code>anyMatch()</code>：匹配流中的元素，类似的操作还有<code>allMatch()</code>和<code>noneMatch()</code>方法</li>
<li><code>findFirst()</code>：查找第一个元素，类似的还有<code>findAny()</code>方法</li>
<li><code>max()</code>：求最大值</li>
<li><code>min()</code>：求最小值</li>
<li><code>count()</code>：求总数</li>
</ul>
<p>下面逐一介绍这些方法的用法。</p>
<h3 id="过滤和排序"><a href="#过滤和排序" class="headerlink" title="过滤和排序"></a>过滤和排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">    .filter(n -&gt; n &gt; <span class="number">2</span>)     <span class="comment">// 对元素过滤，保留大于2的元素</span></span><br><span class="line">    .distinct()             <span class="comment">// 去重，类似于SQL语句中的DISTINCT</span></span><br><span class="line">    .skip(<span class="number">1</span>)                <span class="comment">// 跳过前面1个元素</span></span><br><span class="line">    .limit(<span class="number">2</span>)               <span class="comment">// 返回开头2个元素，类似于SQL语句中的SELECT TOP</span></span><br><span class="line">    .sorted()               <span class="comment">// 对结果排序</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h3><p>Stream中提供的查找方法有<code>anyMatch()</code>、<code>allMatch()</code>、<code>noneMatch()</code>、<code>findFirst()</code>、<code>findAny()</code>，这些方法被用来查找或匹配某些元素是否符合给定的条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查流中的任意元素是否包含字符串"Java"</span></span><br><span class="line"><span class="keyword">boolean</span> hasMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</span><br><span class="line">        .anyMatch(s -&gt; s.equals(<span class="string">"Java"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查流中的所有元素是否都包含字符串"#"</span></span><br><span class="line"><span class="keyword">boolean</span> hasAllMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</span><br><span class="line">        .allMatch(s -&gt; s.contains(<span class="string">"#"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查流中的任意元素是否没有以"C"开头的字符串</span></span><br><span class="line"><span class="keyword">boolean</span> hasNoneMatch = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</span><br><span class="line">        .noneMatch(s -&gt; s.startsWith(<span class="string">"C"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">Optional&lt;String&gt; element = Stream.of(<span class="string">"Java"</span>, <span class="string">"C#"</span>, <span class="string">"PHP"</span>, <span class="string">"C++"</span>, <span class="string">"Python"</span>)</span><br><span class="line">        .filter(s -&gt; s.contains(<span class="string">"C"</span>))</span><br><span class="line">        <span class="comment">// .findFirst()     // 查找第一个元素</span></span><br><span class="line">        .findAny();         <span class="comment">// 查找任意元素</span></span><br></pre></td></tr></table></figure>
<p>注意最后一行代码的返回类型，是一个<code>Optional&lt;T&gt;</code>类（<code>java.util.Optional</code>），它一个容器类，代表一个值存在或不存在。上面的代码中，<code>findAny()</code>可能什么元素都没找到。<code>Optional&lt;T&gt;</code>是Java 8的另一个新特性，有关<code>Optional&lt;T&gt;</code>类的详细用法，将在下一篇文章中介绍。</p>
<p>实际上测试结果发现，<code>findFirst()</code>和<code>findAny()</code>返回的都是第一个元素，那么两者之间到底有什么区别？通过查看javadoc描述，大致意思是<code>findAny()</code>是为了提高并行操作时的性能，如果没有特别需要，还是建议使用<code>findAny()</code>方法。</p>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约操作就是将流中的元素进行合并，形成一个新的值，常见的归约操作包括求和，求最大值或最小值。归约操作一般使用<code>reduce()</code>方法，与<code>map()</code>方法搭配使用，可以处理一些很复杂的归约操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取流</span></span><br><span class="line">List&lt;Book&gt; books = Arrays.asList(</span><br><span class="line">       <span class="keyword">new</span> Book(<span class="string">"Java编程思想"</span>, <span class="string">"Bruce Eckel"</span>, <span class="string">"机械工业出版社"</span>, <span class="number">108.00</span>D),</span><br><span class="line">       <span class="keyword">new</span> Book(<span class="string">"Java 8实战"</span>, <span class="string">"Mario Fusco"</span>, <span class="string">"人民邮电出版社"</span>, <span class="number">79.00</span>D),</span><br><span class="line">       <span class="keyword">new</span> Book(<span class="string">"MongoDB权威指南（第2版）"</span>, <span class="string">"Kristina Chodorow"</span>, <span class="string">"人民邮电出版社"</span>, <span class="number">69.00</span>D)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算所有图书的总价</span></span><br><span class="line">Optional&lt;Double&gt; totalPrice = books.stream()</span><br><span class="line">       .map(Book::getPrice)</span><br><span class="line">       .reduce((n, m) -&gt; n + m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 价格最高的图书</span></span><br><span class="line">Optional&lt;Book&gt; expensive = books.stream().max(Comparator.comparing(Book::getPrice));</span><br><span class="line"><span class="comment">// 价格最低的图书</span></span><br><span class="line">Optional&lt;Book&gt; cheapest = books.stream().min(Comparator.comparing(Book::getPrice));</span><br><span class="line"><span class="comment">// 计算总数</span></span><br><span class="line"><span class="keyword">long</span> count = books.stream().count()</span><br></pre></td></tr></table></figure>
<p>在计算图书总价的时候首先使用<code>map()</code>方法得到所有图书价格的流，然后再使用<code>reduce()</code>方法进行归约计算。与<code>map()</code>方法类似的还有一个<code>flatMap()</code>，通过名字可以看出<code>flatMap()</code>方法是将流进行扁平化操作，看看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = userDAO.selectAllByInstId(instId);</span><br><span class="line">List&lt;List&lt;Role&gt;&gt; userRoles = users.stream()</span><br><span class="line">        .map(User::getOid)</span><br><span class="line">        .map(userId -&gt; &#123;</span><br><span class="line">            List&lt;Role&gt; roles = roleDAO.selectAllByUserId(userId);</span><br><span class="line">            <span class="keyword">return</span> roles;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>首先根据<code>InstId</code>查询所有用户集合，再根据用户获取与其关联的所有角色集合，最终返回结果是一个<code>List&lt;List&lt;Role&gt;&gt;</code>类型，但这不是我们想要的类型，我们想要的是<code>List&lt;Role&gt;</code>这种扁平的集合，这时候<code>flatMap()</code>就派上用场了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = userDAO.selectAllByInstId(instId);</span><br><span class="line">List&lt;Role&gt; userRoles = users.stream()</span><br><span class="line">        .map(User::getOid)</span><br><span class="line">        .map(userId -&gt; &#123;</span><br><span class="line">            List&lt;Role&gt; roles = roleDAO.selectAllByUserId(userId);</span><br><span class="line">            <span class="keyword">return</span> roles;</span><br><span class="line">        &#125;).flatMap(roles -&gt; roles.stream()) <span class="comment">// 扁平化操作</span></span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>第二个<code>map()</code>返回的结果是<code>List&lt;Role&gt;</code>，接着使用<code>flatMap(roles -&gt; roles.stream())</code>扁平化处理，将各个不同的<code>List&lt;Role&gt;</code>合并成一个大的<code>List&lt;Role&gt;</code>。<code>flatMap()</code>适合处理类似于二维数组这种格式，将其扁平化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="string">"A1"</span>);</span><br><span class="line">        add(<span class="string">"A2"</span>);</span><br><span class="line">        add(<span class="string">"A3"</span>);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    add(<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="string">"B1"</span>);</span><br><span class="line">        add(<span class="string">"B2"</span>);</span><br><span class="line">        add(<span class="string">"B3"</span>);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    add(<span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="string">"C1"</span>);</span><br><span class="line">        add(<span class="string">"C2"</span>);</span><br><span class="line">        add(<span class="string">"C3"</span>);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; result = list.stream()</span><br><span class="line">        .flatMap(ls -&gt; ls.stream())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>前面两部分内容分别为流式数据处理的前两个步骤：从数据源创建流、使用流进行中间处理。下面我们介绍流式数据处理的最后一个步骤——数据收集。</p>
<p>数据收集是流式数据处理的终端处理，与中间处理不同的是，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常。数据收集主要使用<code>collect</code>方法，与<code>reduce()</code>方法一样，该方法也属于归约操作，将流中的元素累积成一个汇总结果，具体的做法是通过定义新的<code>Collector</code>接口来定义的。</p>
<p>在前面部分的例子中使用收集器（<code>Collector</code>）是由<code>java.util.stream.Collectors</code>工具类中的<code>toList()</code>方法提供，<code>Collectors</code>类提供了许多常用的方法用于处理数据收集，常见的有归约、汇总、分组等。</p>
<h3 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h3><p>我们使用前面归约操作中计算图书总价，最大值，最小值，输入总数那个例子来看看收集器如何进行上述归约操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">long</span> count = books.stream().collect(counting());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 价格最高的图书</span></span><br><span class="line">Optional&lt;Book&gt; expensive = books.stream().collect(maxBy(comparing(Book::getPrice)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 价格最低的图书</span></span><br><span class="line">Optional&lt;Book&gt; cheapest = books.stream().collect(minBy(comparing(Book::getPrice)));</span><br></pre></td></tr></table></figure>
<p>上面的代码需要使用静态导入<code>Collectors</code>和<code>Comparator</code>两个类，这样你就不用再去写<code>Collectors.counting()</code>和<code>Comparator.comparing()</code>这样的代码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.*;</span><br></pre></td></tr></table></figure>
<p><code>Collectors</code>工具类为我们提供了用于汇总的方法，包括<code>summarizingInt()</code>，<code>summarizingLong()</code>和<code>summarizingDouble()</code>，由于图书的价格为<code>Double</code>类型，所以我们使用<code>summarizingDouble()</code>方法进行汇总。该方法会返回一个<code>DoubleSummaryStatistics</code>对象，包含一系列归约操作的方法，如：汇总、计算平均数、最大值、最小值、计算总数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DoubleSummaryStatistics dss = books.stream().collect(summarizingDouble(Book::getPrice));</span><br><span class="line"><span class="keyword">double</span> sum = dss.getSum();          <span class="comment">// 汇总</span></span><br><span class="line"><span class="keyword">double</span> average = dss.getAverage();  <span class="comment">// 求平均数</span></span><br><span class="line"><span class="keyword">long</span> count = dss.getCount();        <span class="comment">// 计算总数</span></span><br><span class="line"><span class="keyword">double</span> max = dss.getMax();          <span class="comment">// 最大值</span></span><br><span class="line"><span class="keyword">double</span> min = dss.getMin();          <span class="comment">// 最小值</span></span><br></pre></td></tr></table></figure>
<p><code>Collectors</code>类还包含一个<code>joining()</code>方法，该方法用于连接字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).collect(joining(<span class="string">","</span>));</span><br></pre></td></tr></table></figure>
<p>上面的代码用于将流中的字符串通过逗号连接成一个新的字符串。</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>和关系数据库一样，流也提供了类似于数据库中<code>GROUP BY</code>分组的特性，由<code>Collectors.groupingBy()</code>方法提供：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Book&gt;&gt; booksGroup = books.stream().collect(groupingBy(Book::getPublisher));</span><br></pre></td></tr></table></figure>
<p>上面的代码按照出版社对图书进行分组，分组的结果是一个<code>Map</code>对象，<code>Map</code>的<code>key</code>值是出版社的名称，<code>value</code>值是每个出版社分组对应的集合。分组方法<code>groupingBy()</code>接收一个<code>Function</code>接口作为参数，上面的例子中我们使用了方法引用传递了出版社作为分组的依据，但实际情况可能比这复杂，比如将价格在0-50之间的书籍分成一组，50-100之间的分成一组，超过100的分成一组，这时候，我们可以直接使用Lambda表达式来表示这个分组逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Book&gt;&gt; booksGroup = books</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(groupingBy(book -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getPrice() &gt; <span class="number">0</span> &amp;&amp; book.getPrice() &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book.getPrice() &gt; <span class="number">50</span> &amp;&amp; book.getPrice() &lt;=<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p><code>groupingBy()</code>方法还支持多级分组，他有一个重载方法，除了接收一个<code>Function</code>类型的参数外，还接收一个<code>Collector</code>类型的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, List&lt;Book&gt;&gt;&gt; booksGroup = books.stream().collect(</span><br><span class="line">        groupingBy(Book::getPublisher, groupingBy(book -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (book.getPrice() &gt; <span class="number">0</span> &amp;&amp; book.getPrice() &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book.getPrice() &gt; <span class="number">50</span> &amp;&amp; book.getPrice() &lt;=<span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的代码将之前两个分组合并成一个，实现了多级分组，首先按照出版社进行分组，然后按照价格进行分组，返回类型是一个<code>Map&lt;String, Map&lt;String, List&lt;Book&gt;&gt;&gt;</code>。<code>groupingBy()</code>的第二个参数可以是任意类型，只要是<code>Collector</code>接口的实例就可以，比如先分组，再统计数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Long&gt; countGroup = books.stream()</span><br><span class="line">        .collect(groupingBy(Book::getPublisher, counting()));</span><br></pre></td></tr></table></figure>
<p>还可以在进行分组后获取每组中价格最高的图书：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Book&gt; expensiveGroup = books.stream()</span><br><span class="line">        .collect(groupingBy(Book::getPublisher, collectingAndThen(</span><br><span class="line">            maxBy(comparingDouble(Book::getPrice)),</span><br><span class="line">                Optional::get</span><br><span class="line">        )));</span><br></pre></td></tr></table></figure>
<h2 id="并行数据处理"><a href="#并行数据处理" class="headerlink" title="并行数据处理"></a>并行数据处理</h2><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>并行流使用集合的<code>parallelStream()</code>方法可以获取一个并行流。Java内部会将流的内容分割成若干个子部分，然后将它们交给多个线程并行处理，这样就将工作的负担交给多核CPU的其他内核处理。</p>
<p>我们通过一个简单粗暴的例子演示并行流的处理性能。假设有一个方法，接受一个数字n作为参数，返回从1到n的所有自然数之和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sequentialSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">			.limit(n)</span><br><span class="line">			.reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法也可以通过传统的for循环方式实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">iterativeSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1L</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		result += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> number = <span class="number">10000000L</span>;</span><br><span class="line">    System.out.println(<span class="string">"Sequential Sum: "</span> + sumPerformanceTest(StreamTest::sequentialSum, number) + <span class="string">" 毫秒"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Iterative Sum: "</span> + sumPerformanceTest(StreamTest::iterativeSum, number) + <span class="string">" 毫秒"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sumPerformanceTest</span><span class="params">(Function&lt;Long, Long&gt; function, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> maxValue = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">		<span class="keyword">long</span> sum = function.apply(n);</span><br><span class="line">		<span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">"Result: "</span> + sum);</span><br><span class="line">		<span class="keyword">long</span> time = ( end - start ) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (time &lt; maxValue) &#123;</span><br><span class="line">			maxValue = time;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的测试代码中我们编写了一个<code>sumPerformanceTest()</code>方法，参数<code>number</code>表示给定的一个数，用于计算从1到这个数的所有自然数之和。该方法内部执行10次运算，返回时间最短的一次运算结果。</p>
<p>运行上面的代码，可以在控制台看到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Sequential Sum: 159 毫秒</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Iterative Sum: 5 毫秒</span><br></pre></td></tr></table></figure>
<p>从结果来看，采用传统的for循环更快，因为它不用做任何自动拆箱/装箱操作，操作的都是基本类型。这个测试结果并不客观，提升的性能取决于机器的配置，以上是我在公司的台式机（机器配置为<code>Intel(R) Core i7-6700 CPU 3.40HZ; 8GB RAM</code>）上运行的结果。</p>
<p>现在我们使用并行流测试一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">			.limit(n)</span><br><span class="line">			.parallel()</span><br><span class="line">			.reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Parallel Sum: "</span> + sumPerformanceTest(StreamTest::parallelSum, number) + <span class="string">" 毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并行流执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Parallel Sum: 570 毫秒</span><br></pre></td></tr></table></figure>
<p>并行的执行效率比顺序执行还要慢，这个结果有点出乎意料。主要有两个原因：</p>
<ol>
<li><code>iterate()</code>方法生成的对象是基本类型的包装类（也就是<code>java.lang.Long</code>类型），必须进行拆箱操作才能运算。</li>
<li><code>iterate()</code>方法不适合用并行流处理。</li>
</ol>
<p>第一个原因容易理解，自动拆箱操作确实需要花费一定的时间，这从前一个例子可以看出来。</p>
<p>第二个原因中<code>iterate()</code>方法不适合用并行流处理，主要原因是<code>iterate()</code>方法内部机制的问题。<code>iterate()</code>方法每次执行都需要依赖前一次的结果，比如本次执行的输入值为10，这个输入值必须是前一次运算结果的输出，因此<code>iterate()</code>方法很难使用并行流分割成不同小块处理。实际上，上面的并行流程序还增加了顺序处理的额外开销，因为需要把每次操作执行的结果分别分配到不同的线程中。</p>
<p>一个有效的处理方式是使用<code>LongStream.rangeClosed()</code>方法，该方法弥补了上述例子的两个缺点，它生成的是基本类型而非包装类，不用拆箱操作就可以运算，并且，它生成的是有范围的数字，很容易拆分。如：生成1-20范围的数字可以拆分成1-10, 11-20。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">rangedSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n)</span><br><span class="line">			.reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Ranged Sum: "</span> + sumPerformanceTest(StreamTest::rangedSum, number) + <span class="string">" 毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Ranged Sum: 8 毫秒</span><br></pre></td></tr></table></figure>
<p>这个结果比起<code>sequentialSum()</code>方法执行的结果还要快，所以选择合适的数据结构有时候比并行化处理更重要。我们再将<code>rangeClosed()</code>方法生成的流转化为并行流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelRangedSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Parallel Ranged Sum: "</span> + sumPerformanceTest(StreamTest::parallelRangedSum, number) + <span class="string">" 毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Result: 200000010000000</span><br><span class="line">Parallel Ranged Sum: 2 毫秒</span><br></pre></td></tr></table></figure>
<p>我们终于得到了想要的结果，所以并行操作需要选择合适的数据结构，建议多做测试，找到合适的并行方式再执行，否则很容易跳到坑里。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>学习笔记：原码，反码和补码</title>
    <url>/notes/true_code_ones-complement_code_complemental_code.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/java8-logo.jpeg"></p>
<a id="more"></a>
<h1 id="一道面试题的思考"><a href="#一道面试题的思考" class="headerlink" title="一道面试题的思考"></a>一道面试题的思考</h1><p>最近找工作，面试了几家公司，其中有一道面试题印象深刻：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">12</span>;</span><br><span class="line">Integer b = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">Integer c = <span class="number">225</span>;</span><br><span class="line">Integer d = <span class="number">225</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure>
<p>正确答案是第一个<code>true</code>，第二个为<code>false</code>。</p>
<p>面试官又问原因，我回答：因为Integer中有一个常量池，在<code>-128 ~ 127</code>这个范围内的数会直接从常亮池中获取（具体在Integer源码中有实现）。</p>
<p>面试官接着又问：为什么常亮池规定范围是<code>-128 ~ 127</code>，而不是其他？emmm……这个还真没仔细研究过。</p>
<p>为了彻底弄明白，事后我又查了很多资料，发现这货原来就是我们大学时候计算机基础里面的原码，反码和补码那一块内容。毕业这么多年早忘了，这是以前只有考试时候才会临时抱佛脚死记硬背一遍的知识，整理这篇文章，就算是重新复习一下吧。</p>
<h1 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h1><p>在了解原码，反码和补码之前，我们首先来了解一下机器数和真值的概念。</p>
<h2 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h2><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机中用一个数的二进制最高位存放符号，正数为0，负数为1。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十进制		二进制</span><br><span class="line">+1		0000 0001</span><br><span class="line">-1		1000 0001</span><br></pre></td></tr></table></figure>
<h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><p>第一位是符号位，所以机器数的值不等于真实的值。比如上面的<code>1000 0001</code>，最高位为1，代表负数，真实值为-1，而不是129。因此，为了区别，将带符号位的机器数对应的真正数值称为机器数的真值。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0001的真值 = +000 0001</span><br><span class="line">1000 0001的真值 = -000 0001</span><br></pre></td></tr></table></figure>
<h1 id="原码，反码和补码"><a href="#原码，反码和补码" class="headerlink" title="原码，反码和补码"></a>原码，反码和补码</h1><p>在探究为何机器要使用补码之前，我们先来了解原码，反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储，原码，反码和补码是机器存储一个具体数字的编码方式。</p>
<h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码就是符号位加上真值的绝对值，即用第一位表示符号位，其余位表示值，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure>
<p>由于第一位是符号位，所以8位二进制数的取值范围是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1111 1111, 0111 1111]</span><br></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[-127, 127]</span><br></pre></td></tr></table></figure>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>反码的表示方法：</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是其原码的基础上，符号位不变，其余各个位取反</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1] = [0000 0001]原 = [0000 0001]反</span><br><span class="line">[-1] = [1000 0001]原 = [1111 1110]反</span><br></pre></td></tr></table></figure>
<p>可见如果一个反码表示的是负数，人脑是无法通过直接观察来得到它的数值，通常要将它转换成原码再计算。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码的表示方法：</p>
<ul>
<li>正数的补码是其本身</li>
<li>负数的补码是其原码的基础上，符号位不变，其余各个位取反，然后+1（即在反码的基础上+1）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补</span><br><span class="line">[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补</span><br></pre></td></tr></table></figure>
<p>对于负数的补码，人脑也是无法通过直接观察来得到它的数值，通常也要转化成原码再计算。</p>
<h1 id="为什么要使用原码，反码和补码"><a href="#为什么要使用原码，反码和补码" class="headerlink" title="为什么要使用原码，反码和补码"></a>为什么要使用原码，反码和补码</h1><p>现在我们知道计算机有三种编码方式表示一个二进制数，对于正数，这三种编码方式的结果都相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补</span><br></pre></td></tr></table></figure>
<p>所以无需做过多解释，对于负数，三种编码方式结果都不一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补</span><br></pre></td></tr></table></figure>
<p>可见负数的原码，反码和补码完全不同，既然原码才是人脑直接识别并用于计算的方式，为何还要引入反码和补码？</p>
<p>首先，人脑可以知道第一位是符号位，在计算的时候，我们可以根据第一位的符号位，选择真值区域进行加减。但是对于计算机，加减乘除是最基本的运算，要设计的尽量简单。计算机鉴别符号位显然会让计算机的基础电路设计变得十分复杂，于是人们想到了将符号位也参与进来运算的方法。</p>
<p>我们知道，根据运算法则，减去一个正数等于加上这个数的负数，即：<code>1 - 1 = 1 + (-1) = 0</code></p>
<p>所以机器可以只有加法而没有减法，这样设计计算机的运算就变得很简单。于是人们开始探索，将符号位也参与运算，并且只保留加法的方法，首先来看原码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2</span><br></pre></td></tr></table></figure>
<p>如果用原码表示，让符号位也参与运算，对于减法来说，这个结果显然是不对的，1 - 1怎么也不可能等于-2。这也就是为什么计算机内部不使用原码表示一个数。</p>
<p>为了解决原码做减法的问题，引入了反码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</span><br></pre></td></tr></table></figure>
<p>如果用反码做减法运算，计算结果部分是正确的，问题就出现在-0上。虽然我们知道+0和-0是一样的，但是带符号的0实际上是没有意义的，并且会有<code>[0000 0000]</code><sub>原</sub>和<code>[1000 0000]</code><sub>原</sub>两个编码表示0。</p>
<p>于是出现了补码，解决了0的符号问题以及两个编码的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原 = 0</span><br></pre></td></tr></table></figure>
<p>这样0就可以用<code>[0000 0000]</code>表示，之前出现的-0也就不存在了，而且可以用<code>[1000 0000]</code>表示-128：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 = -128</span><br></pre></td></tr></table></figure>
<p>-1 - 127的结果是-128，与运算结果一致。值得注意的是由于用以前的-0的补码来表示-128，所以-128实际上并没有原码和反码表示（-128的补码<code>[1000 0000]</code><sub>补</sub>算出来的原码是<code>[0000 0000]</code><sub>原</sub>，这是不正确的）。</p>
<p>回到本文最开始提到的面试题，使用补码，不仅修复了0的符号以及存在两个编码的问题，而且可以多表示一个最低数，这就是为什么8位二进制，用原码或反码表示的范围是<code>[-127, 127]</code>，而使用补码表示的范围是<code>[-128, 127]</code>。</p>
<p>因为机器使用补码，所以对于编程常用到的32位int型，可以表示的范围是[-2<sup>31</sup>, 2<sup>31</sup> - 1]，因为第一位表示符号位，使用补码时又可以多表示一个最小值。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>上面提到了用补码表示8位二进制的范围<code>[-128, 127]</code>，为什么要使用8位二进制？</p>
<p>在计算机中，一个字节长度是8位，使用一个字节就可以存放ASCII编码，也就是所有的数字，大小写字母和一些特殊字符（总共有255个）。</p>
<p>8位二进制表示的最大值是255，刚好能表示255个ASCII字符。而我们使用的汉字用UNICODE编码，UNICODE编码要用2个字节，所以要使用16位二进制数才能表示一个UNICODE字符。</p>
<p>另外，一个UTF-8编码占4个字节。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Cloud 微服务：Spring Cloud Config</title>
    <url>/spring-cloud/spring-cloud-config.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/spring-cloud-logo.jpeg"></p>
<p>前段时间工作太忙，博客好长时间暂停更新，正好现在空闲时间，把最近工作中学到的技术总结一下，分享给大家。</p>
<p>这篇文章是Spring Cloud系列的第一篇，首先从Spring Cloud Config这个项目说起吧，它是一个分布式配置中心服务，用于为分布式系统中各个微服务提供外部配置支持。</p>
<a id="more"></a>
<h2 id="Spring-Cloud-Config简介"><a href="#Spring-Cloud-Config简介" class="headerlink" title="Spring Cloud Config简介"></a>Spring Cloud Config简介</h2><p>Spring Cloud Config项目分为两部分，客户端和服务器（简单起见，我们统一称为Config Client和Config Server）。</p>
<p>Config Server是一个微服务应用，用于提供集中的外部配置支持，也就是我们前面提到的分布式配置中心。Config Server支持连接外部的配置仓库来管理各个微服务的配置文件，配置仓库可以是Git、Svn或本地文件系统。此外，Config Server还支持配置文件加密/解密、多仓库支持、动态刷新配置、自动推送配置等，这篇文章将会逐一介绍这些特性。</p>
<p>Config Client是用于连接到Config Server的客户端，它也是一个微服务应用，Config Client在启动的时候从Config Server中获取对于的配置信息，然后加载到Spring容器中。</p>
<p>下面我们来创建并启动一个Config Server，看看它是如何运行的。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="构建Config-Server"><a href="#构建Config-Server" class="headerlink" title="构建Config Server"></a>构建Config Server</h3><p>可以在<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a>上生成一个Spring Boot项目，也可以使用Spring Tool Suite或IntelliJ IDEA等IDE创建，支持Maven和Gradle两种构建工具，这里我选择Gradle作为构建工具，采用Gradle多模块方式构建。</p>
<p>创建一个<code>springcloud-config-server</code>的子项目，并在<code>build.gradle</code>文件中引入<code>spring-cloud-config-server</code>依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.cloud:spring-cloud-config-server'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Spring Boot的启动主类中添加<code>@EnableConfigServer</code>注解，表示开启Config Server功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.matrixstudio.springcloud.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>application.properties</code>配置文件中添加仓库配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.server.git.uri=https://github.com/lw900925/springcloud-config-repository.git</span><br><span class="line">spring.cloud.config.server.git.search-paths=base-service</span><br><span class="line">#spring.cloud.config.server.git.username=username</span><br><span class="line">#spring.cloud.config.server.git.password=password</span><br><span class="line">spring.cloud.config.server.git.timeout=60</span><br></pre></td></tr></table></figure>
<p><strong> 配置详解 </strong></p>
<ul>
<li><code>spring.cloud.config.server.git.uri</code>：Config Server需要连接的Git仓库地址</li>
<li><code>spring.cloud.config.server.git.search-paths</code>：Config Server所连接仓库的搜索路径（你可以将不同类型服务的配置文件分别放在不同的目录中，方便管理，然后通过指定该属性让Config Server找到它们）</li>
<li><code>spring.cloud.config.server.git.username</code>：连接到Git仓库的用户名（这里使用的仓库未public类型，所以不需要用户名和密码）</li>
<li><code>spring.cloud.config.server.git.password</code>：连接到Git仓库的密码</li>
<li><code>spring.cloud.config.server.git.timeout</code>：连接到Git的超时时间，单位为秒（second），默认值为5</li>
</ul>
<p>至此，Config Server服务搭建完毕了，现在可以在<code>springcloud-config-server</code>目录下通过执行<code>gradle bootRun</code>命令运行项目。</p>
<h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>在上面的<code>application.properties</code>配置文件中指定了一个Github仓库地址<code>https://github.com/lw900925/springcloud-config-repository.git</code>作为配置仓库，我们需要在该仓库中添加一些配置文件以便Config Server启动后可以访问到它们。</p>
<p>首先在仓库中创建一个<code>base-service</code>的目录，并在该目录下添加两个配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">springcloud-file-service-dev.properties</span><br><span class="line">springcloud-file-service-test.properties</span><br></pre></td></tr></table></figure>
<p>上面两个配置文件分别表示名称为<code>springcloud-file-service</code>的微服务应用的开发环境和测试环境的配置文件（<code>springcloud-file-service</code>微服务将在后面构建），配置文件的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=springcloud-file-service</span><br><span class="line"></span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<p><strong><em> 注 </em></strong>：<code>springcloud-file-service-test.properties</code>文件中的<code>spring.profiles.active</code>为<code>test</code>。</p>
<p>文件添加完毕后，推送到远程仓库，就可以启动Config Server来测试了，这里使用了<code>8888</code>作为Config Server的端口，我们可以通过<code>curl</code>命令或浏览器地址栏来测试Config Server从远程Git仓库获取配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8888/springcloud-file-service/dev | python -mjson.tool</span><br></pre></td></tr></table></figure>
<p>上面的命令在Windows环境下执行需要安装Python运行环境和curl工具，如果不想安装也可以通过浏览器地址访问。上述命令执行结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"springcloud-file-service"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"dev"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"propertySources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://github.com/lw900925/springcloud-config-repository.git/base-service/springcloud-file-service-dev.properties"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: &#123;</span><br><span class="line">                <span class="attr">"spring.profiles.active"</span>: <span class="string">"dev"</span>,</span><br><span class="line">                <span class="attr">"spring.application.name"</span>: <span class="string">"springcloud-file-service"</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你发现在请求的URL里包含了配置文件的名称和环境信息，Config Server正是通过这两个参数定位具体的配置文件的，Config Server会将配置文件的URL映射出来（可以在Config Server的启动日志中找到映射信息），它们的对应关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>
<p><code>application</code>表示微服务的名称，也就是上面请求URL中的<code>springcloud-file-service</code>；<code>profile</code>表示对于的环境，即<code>dev</code>；<code>label</code>是可选参数，表示Git分支名称，因为Config Server默认从<code>master</code>分支作获取配置文件，所以该参数可以省略，如果配置文件放在其他分支，就需要指定该参数值。</p>
<h3 id="构建Config-Client"><a href="#构建Config-Client" class="headerlink" title="构建Config Client"></a>构建Config Client</h3><p>通过Config Server我们已经可以手动获取对应微服务应用的配置文件了，接下来通过在微服务中获取配置文件。</p>
<p>首先需要创建一个项目，命名为<code>springcloud-file-service</code>，并在<code>build.gradle</code>文件中添加<code>spring-cloud-starter-config</code>依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-config'</span>)</span><br><span class="line"></span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为项目需要在启动的时候获取配置信息，所以需要添加<code>bootstrap.properties</code>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=springcloud-file-service</span><br><span class="line"></span><br><span class="line">spring.profiles.active=dev</span><br><span class="line"></span><br><span class="line"># Spring cloud config client</span><br><span class="line">spring.cloud.config.label=master</span><br><span class="line">spring.cloud.config.uri=http://localhost:8888</span><br></pre></td></tr></table></figure>
<p>启动<code>springcloud-file-service</code>应用，通过访问<code>/env.json</code>路径，可以看到配置信息已经获取到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;profiles&quot;: [</span><br><span class="line">        &quot;dev&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;server.ports&quot;: &#123;</span><br><span class="line">        &quot;local.server.port&quot;: &quot;8000&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;configService:https://github.com/lw900925/springcloud-config-repository.git/base-service/springcloud-file-service-dev.properties&quot;: &#123;</span><br><span class="line">        &quot;spring.profiles.active&quot;: &quot;dev&quot;,</span><br><span class="line">        &quot;spring.application.name&quot;: &quot;springcloud-file-service&quot;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 以下部分省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Config-Server多仓库支持"><a href="#Config-Server多仓库支持" class="headerlink" title="Config Server多仓库支持"></a>Config Server多仓库支持</h2><p>由于一些复杂的需求，配置文件往往分布在不同的Git仓库中，Config Server支持多仓库的配置，我们可以将生产、开发、测试环境的配置文件分别放在不同的Git仓库，需要在<code>springcloud-config-server</code>应用中的<code>application.properties</code>配置文件中添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring cloud config server</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/lw900925/springcloud-config-repository.git</span><br><span class="line">spring.cloud.config.server.git.search-paths=base-service</span><br><span class="line">#spring.cloud.config.server.git.username=username</span><br><span class="line">#spring.cloud.config.server.git.password=password</span><br><span class="line">spring.cloud.config.server.git.timeout=60</span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.repos.prod.uri=https://gitlab.com/lw900925/springcloud-config-repository.git</span><br><span class="line">spring.cloud.config.server.git.repos.prod.pattern=*prod*</span><br><span class="line">spring.cloud.config.server.git.repos.prod.searchPaths=base-service</span><br><span class="line">spring.cloud.config.server.git.repos.prod.timeout=60</span><br></pre></td></tr></table></figure>
<p>通过<code>spring.cloud.config.server.git.repos.*</code>配置不同的仓库，上述配置文件中添加了一个<code>prod</code>的库作为生产环境的Github库，当获取<code>prod</code>环境的配置文件时，Config Server首先会在该库中获取配置文件，如果没有获取到，就会进入默认的库中获取。</p>
<h2 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h2><p>由于Config Server中的配置文件信息比较敏感，如果没有做限制，任何人可以通过Config Server获取配置信息，会有很大隐患。配置Config Server以安全方式访问有很多种方法，如OAuth2.0认证，防火墙白名单等，这里推荐使用Spring Security项目，他可以和Spring Boot项目无缝整合。</p>
<h3 id="Config-Server配置"><a href="#Config-Server配置" class="headerlink" title="Config Server配置"></a>Config Server配置</h3><p>在<code>springcloud-config-server</code>项目中的<code>build.gradle</code>文件添加<code>spring-boot-starter-security</code>依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-security'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Security默认使用HTTP Basic方式认证，当启动Config Server时，可以在控制台看到如下日志信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2017-08-15 16:19:27.319  INFO 13720 --- [           main] b.a.s.AuthenticationManagerConfiguration : </span><br><span class="line"></span><br><span class="line">Using default security password: 5cd88fb5-0f77-4560-a3fe-7815f742862b</span><br></pre></td></tr></table></figure>
<p>此时通过浏览器访问Config Server会提示输入用户名和密码，用户名默认为<code>user</code>，密码即上面日志中输出的UUID，每次重新启动Config Server时会重新生成，如果不希望每次启动Config Server都重新生成密码，可以在<code>application.properties</code>中修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security.user.name=spring</span><br><span class="line">security.user.password=password</span><br></pre></td></tr></table></figure>
<h3 id="Config-Client配置"><a href="#Config-Client配置" class="headerlink" title="Config Client配置"></a>Config Client配置</h3><p>在<code>springcloud-file-service</code>项目的<code>bootstrap.properties</code>文件中添加Config Server的认证信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.username=user</span><br><span class="line">spring.cloud.config.password=password</span><br></pre></td></tr></table></figure>
<h2 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h2><p>一些敏感的配置信息（如数据库连接信息）如果以明文方式存放在配置文件中，一旦泄露，将会造成不可挽回的损失。Config Server支持配置信息加密，加密后以密文存储在配置文件中，保证配置信息的安全。</p>
<p>使用加密/解密特性需要JCE（Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files）的支持，默认的JCE在Sun的jre版本中自带，不过有长度限制，使用时可能会抛出<code>java.security.InvalidKeyException: Illegal key size</code>异常信息，所以我们需要安装Oracle提供的不限长度的JCE，下载传送门：</p>
<ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_blank" rel="noopener">Java 6 JCE</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_blank" rel="noopener">Java 7 JCE</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">Java 8 JCE</a></li>
</ul>
<p>请根据所使用的JDK版本对号入座，下载后是一个zip包，解压到JDK安装目录下<code>/jre/lib/security</code>目录中覆盖原来的即可。</p>
<p>安装好JCE后，可以开启Config Server，在控制台中查看启动日志，可以发现加密/解密的相关端点（Endpoint）：</p>
<ul>
<li><code>[/encrypt],methods=[POST]</code></li>
<li><code>[/encrypt/{name}/{profiles}],methods=[POST]</code></li>
<li><code>[/decrypt/{name}/{profiles}],methods=[POST]</code></li>
<li><code>[/decrypt],methods=[POST]</code></li>
<li><code>[/encrypt/status],methods=[GET]</code></li>
<li><code>[/key],methods=[GET]</code></li>
<li><code>[/key/{name}/{profiles}],methods=[GET]</code></li>
</ul>
<p>此时如果访问<code>/encrypt/status</code>端点会返回如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"No key was installed for encryption service"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"NO_KEY"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为没有配置密钥，在<code>application.properties</code>配置文件中添加加密的密钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encrypt.key=config_server_key</span><br></pre></td></tr></table></figure>
<p>添加完成后再次访问<code>/encrypt/status</code>端点，显示加密功能可用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"OK"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在访问加密解密端点查看能否正常加解密：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://user:password@localhost:8888/encrypt -d password</span><br><span class="line">7b113712cc107539d41c4e4343e13da38411f2c66d916841a273eb58a6585818</span><br><span class="line"></span><br><span class="line">curl http://user:password@localhost:8888/decrypt -d 7b113712cc107539d41c4e4343e13da38411f2c66d916841a273eb58a6585818</span><br><span class="line">password</span><br></pre></td></tr></table></figure>
<p>除了使用密钥加密外，Config Server还支持证书加密，这种加密方式使用起来有点复杂，但比使用密钥的方式更安全。首先，需要用JDK自带的<code>keytool</code>命令生成证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkeypair -alias spring-cloud-config-server -keyalg RSA \</span><br><span class="line">  -dname &quot;CN=zh-CN, OU=spring.io, O=spring, L=Shanghai, S=Shanghai, C=CN&quot; \</span><br><span class="line">  -keypass 123456 -keystore .keystore -storepass 123456</span><br></pre></td></tr></table></figure>
<p>默认会在当前用户目录下生成<code>.keystore</code>证书文件，将该文件拷贝到<code>springcloud-config-server</code>项目的<code>/src/main/resources</code>目录下，然后在<code>application.properties</code>中添加以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encrypt.key-store.location=classpath:.keystore</span><br><span class="line">encrypt.key-store.alias=spring-cloud-config-server</span><br><span class="line">encrypt.key-store.password=123456</span><br><span class="line">encrypt.key-store.secret=123456</span><br></pre></td></tr></table></figure>
<p>重新启动Config Server，访问加密解密端点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://user:password@localhost:8888/encrypt -d password</span><br><span class="line">AQBp7YRFbAyDkoVtrxymRrmhzfLfxuVIfvhLHcRT/uRbfJn87TRkwds509uq7BbMxGn2xqCTeLNguN0uBHxVHETlHsh8PabJuVwZAsRFw0Q9nXbU+KdLiaUroLIbtqpQgKltzq91lsKSciXauX5JGzOqgkJhy81UfCgJFeR4m3EmWm8b/EV8Bs0KVekkHCMyyxZwja2wABDyd9BRX4mMCzNuFQ5bHT3RKhgbFWuwewSJC3dFhmLhUYczuT2xqTm/0rp6+zq22tugr9ils9814p2JGpz8o+fQc86i6nOzWKl2+ab3E3aLdG/7tMWHhv6mEmO5/dvcqFz4BHdeN6slsNaWedrxO9hkcWlK7nxwIKLVahutN42n+8a1hg3A+lsp8PY=</span><br><span class="line"></span><br><span class="line">curl http://user:password@localhost:8888/decrypt -d AQBp7YRFbAyDkoVtrxymRrmhzfLfxuVIfvhLHcRT/uRbfJn87TRkwds509uq7BbMxGn2xqCTeLNguN0uBHxVHETlHsh8PabJuVwZAsRFw0Q9nXbU+KdLiaUroLIbtqpQgKltzq91lsKSciXauX5JGzOqgkJhy81UfCgJFeR4m3EmWm8b/EV8Bs0KVekkHCMyyxZwja2wABDyd9BRX4mMCzNuFQ5bHT3RKhgbFWuwewSJC3dFhmLhUYczuT2xqTm/0rp6+zq22tugr9ils9814p2JGpz8o+fQc86i6nOzWKl2+ab3E3aLdG/7tMWHhv6mEmO5/dvcqFz4BHdeN6slsNaWedrxO9hkcWlK7nxwIKLVahutN42n+8a1hg3A+lsp8PY=</span><br><span class="line">password</span><br></pre></td></tr></table></figure>
<p>现在可以将加密后的密文存储在配置文件中，密文在配置文件中需要以<code>{cipher}</code>标记开头，Config Server在获取到配置文件时检查变量值如果以<code>{cipher}</code>开头，就认为是一段密文，会对其进行解密。这里可以为<code>springcloud-file-service</code>配置数据库的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring datasource</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/file-service</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=&#123;cipher&#125;AQBrf7mTx037Xt6r6gKV0LO63RdZJSMHyVDgE9hQqb9ZUtij9XtW0ZSFaD1oiCmSVBTNtU8/0yXnahwuOS2sWptOAdPRLkXwG3BjZFuOt50cV/wiU6OkdShPshsOEHgI7OSWXjXqpv57JyptgId91iFx7eRyQARaYZKlJenh5RCdDGGiBD+cf41d3EtuuEp3IiWnw9zA9QplTjnO3+zgWgRvAPPtcqt0sII9Fk62241w+TPrPxHeJK+HKnoqFG+DJGvTC9PxNqWD1i/v5dFEpse4TSWUMpqXJsi3y+JUTcL+rBwR+I9NoOS81EA4R1sFBrocpFi43rEltG4wppES5ZBREnz+SdHWYa8RzFDajXP38tjFu6lmZj5sCjLxsY7+o18=</span><br></pre></td></tr></table></figure>
<p>将配置文件推送到远程Git仓库，启动Config Server即可。</p>
<h2 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h2><p>有时候我们修改某个微服务的配置文件，推送到远程Git仓库，然后将该微服务重新启动，以便让它从Config Server获取最新的配置文件，但如果改为服务是集群部署（比如有10个实例的集群），逐个重启的做法效率太低。好在Spring Cloud Config为我们提供了动态刷新某个微服务配置的支持，只要在该微服务上访问刷新配置的端点即可。</p>
<p>动态刷新需要添加<code>spring-boot-starter-actuator</code>依赖，在<code>springcloud-file-service</code>项目中<code>build.gradle</code>添加如下依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动<code>springcloud-file-service</code>项目后在控制台查看启动日志可以发现多了一个<code>/refresh</code>的端点，该端点就是刷新配置，首先我们访问<code>/env.json</code>端点查看远程仓库的配置信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"dev"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"server.ports"</span>: &#123;</span><br><span class="line">        <span class="attr">"local.server.port"</span>: <span class="string">"8000"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"configService:https://github.com/lw900925/springcloud-config-repository.git/base-service/springcloud-file-service-dev.properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"spring.datasource.username"</span>: <span class="string">"root"</span>,</span><br><span class="line">        <span class="attr">"spring.profiles.active"</span>: <span class="string">"dev"</span>,</span><br><span class="line">        <span class="attr">"spring.datasource.url"</span>: <span class="string">"jdbc:mysql://localhost:3306/file-service"</span>,</span><br><span class="line">        <span class="attr">"spring.application.name"</span>: <span class="string">"springcloud-file-service"</span>,</span><br><span class="line">        <span class="attr">"spring.datasource.password"</span>: <span class="string">"******"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下信息省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>spring.datasource.url</code>为<code>jdbc:mysql://127.0.0.1:3306/file-service</code>，并推送到远程Git仓库，然后访问<code>springcloud-file-service</code>的<code>/refresh</code>端点：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="string">"spring.datasource.url"</span>]</span><br></pre></td></tr></table></figure>
<p>输出信息表示<code>spring.datasource.url</code>的值已刷新，再次请求<code>/env.json</code>端点：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"dev"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"server.ports"</span>: &#123;</span><br><span class="line">        <span class="attr">"local.server.port"</span>: <span class="string">"8000"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"configService:https://github.com/lw900925/springcloud-config-repository.git/base-service/springcloud-file-service-dev.properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"spring.datasource.username"</span>: <span class="string">"root"</span>,</span><br><span class="line">        <span class="attr">"spring.profiles.active"</span>: <span class="string">"dev"</span>,</span><br><span class="line">        <span class="attr">"spring.datasource.url"</span>: <span class="string">"jdbc:mysql://127.0.0.1:3306/file-service"</span>,</span><br><span class="line">        <span class="attr">"spring.application.name"</span>: <span class="string">"springcloud-file-service"</span>,</span><br><span class="line">        <span class="attr">"spring.datasource.password"</span>: <span class="string">"******"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下信息省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>spring.datasource.url</code>值已经变成修改后的值，这期间<code>springcloud-file-service</code>没有重启，即实现了配置热加载。</p>
<h2 id="自动推送配置"><a href="#自动推送配置" class="headerlink" title="自动推送配置"></a>自动推送配置</h2><p>前面介绍了在不重启微服务的情况下刷新配置文件，不过这种方式依然比较繁琐，即使不重启微服务，也是需要手动请求每个微服务的<code>/refresh</code>端点，如果集群中运行的实例较多，这种操作枯燥而又费时，也许可以使用脚本批量操作，不过Spring Cloud Config为我们提供了更自动化的方式。</p>
<p>自动推送配置需要配合Spring Cloud Bus项目实现，Spring Cloud Bus为微服务提供消息总线功能，关于Spring Cloud Bus项目将在后面的文章中做详细介绍，这里我们可以先用起来。整个流程大致如下：</p>
<p>Spring Cloud Bus有两种实现，RabbitMQ和Kafka，此处选用RabbitMQ作为实现，需要分别在<code>springcloud-config-server</code>和<code>springcloud-file-service</code>项目中添加依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-bus-amqp'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后分别修改两个项目的<code>application.properties</code>配置文件，添加RabbitMQ配置（需要安装RabbitMQ，具体请参考RabbitMQ官方文档）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring RabbitMQ</span><br><span class="line">spring.rabbitmq.host=10.145.4.171</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure>
<p>最后重启两个项目，发现启动日志中新增了<code>/bus/refresh</code>端点，该端点接受一个<code>destination</code>作为参数，<code>destination</code>是配置文件中<code>spring.application.name</code>的值，请求格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST http://user:password@localhost:8888/bus/refresh?destination=springcloud-file-service:**</span><br><span class="line">POST http://user:password@localhost:8888/bus/refresh?destination=springcloud-file-service:8000</span><br></pre></td></tr></table></figure>
<p><code>destination</code>指定某个微服务的名称，如果只刷新某几个实例的配置，直接指定端口号即可，<code>**</code>表示刷新所有微服务实例的配置。</p>
<p>一些代码仓库服务（如Gitlab、Githun、Bitbucket等）都提供了发送通知消息的功能（通过webhook实现），当本地仓库的变更推送到远程仓库时，远程仓库会发送请求到指定的URL中，该URL通常是Config Server的地址。当Config Server接收到远程仓库发送的请求，会对其进行解析，然后更新微服务的配置。</p>
<p>要让自动推送的功能正常运行，需要在<code>springcloud-config-server</code>项目添加<code>spring-cloud-config-monitor</code>依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.cloud:spring-cloud-config-monitor'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完成后重启Config Server，可以在启动日志中看到新增<code>/monitor</code>端点，该端点就是接收Git远程仓库通知的端点。由于Config Server配置了Spring Security的安全认证，还需要在<code>application.properties</code>中添加配置让Spring Security排除掉<code>/monitor</code>端点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security.ignored=/monitor</span><br></pre></td></tr></table></figure>
<p>然后在Git仓库中配置webhook的Payload URL为<code>http://112.65.18.61:8000/monitor</code>（如何配置wenhook请自行Google or Baidu），并确保勾选Push events。</p>
<p>如果不想排除<code>/monitor</code>端点，也可以将验证信息配置在Payload URL中，例如<code>http://user:password@112.65.18.61:8000/monitor</code>（不太推荐这种做法）。</p>
<blockquote>
<p><strong> 注意 </strong>：Playload URL指向Config Server的服务，请将该服务的IP和端口映射到外网，确保Github或Gitlab可以访问到。如果使用自建的Gitlab，也请确保该URL能被Gitlab访问到。</p>
</blockquote>
<p>最后，附上项目源码地址：</p>
<ul>
<li>spring-cloud：<a href="https://github.com/lw900925/springcloud" target="_blank" rel="noopener">https://github.com/lw900925/springcloud</a></li>
<li>spring-cloud-config-repository (github): <a href="https://github.com/lw900925/springcloud-config-repository" target="_blank" rel="noopener">https://github.com/lw900925/springcloud-config-repository</a></li>
<li>spring-cloud-config-repository (gitlab): <a href="https://gitlab.com/lw900925/springcloud-config-repository" target="_blank" rel="noopener">https://gitlab.com/lw900925/springcloud-config-repository</a></li>
</ul>
<p>如果有疑问，请在下方评论区参与讨论。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Cloud 微服务：Spring Cloud Eureka</title>
    <url>/spring-cloud/spring-cloud-eureka.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/spring-cloud-logo.jpeg"></p>
<p>这篇主要介绍Spring Cloud Netflix套件中比较重要的模块——Spring Cloud Eureka，使用Spring Cloud Eureka搭建注册中心，并配置为高可用，以及将其他微服务注册到Eureka上。</p>
<a id="more"></a>
<h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>想象一下我们在之前的开发模式中，如果某个服务需要调用另一个服务提供的接口，我们需要知道被调用服务的IP地址，该IP地址必须是固定的，通常会将该IP写在配置文件中维护。不过，在微服务架构模式中，所有微服务实例都是集群部署，如果还按照手动维护配置文件中的服务IP地址，很容易出错，而且维护工作量大，这就需要一个统一维护服务IP清单的注册中心。</p>
<p>服务注册通常都会依赖注册中心，注册中心是服务发现的关键部分，它是包含各个服务实例网络地址的数据库。注册中心要保证高可用和及时更新，客户端定期从注册中心获取最新的服务清单。注册中心还需要定期检测清单中的服务是否可用，将不可用的服务剔除。</p>
<p>服务的发现主要有两种：客户端发现和服务端发现。Netflix OSS套件中的Eureka就属于客户端发现，客户端从注册中心获取可用的服务清单，然后使用负载均衡算法向其中某个服务发起请求；另一种是服务端发现，客户端通过负载均衡向指定服务发起请求，负载均衡首先查询注册中心，将请求转发到可用的服务上。</p>
<h2 id="Spring-Cloud-Eureka简介"><a href="#Spring-Cloud-Eureka简介" class="headerlink" title="Spring Cloud Eureka简介"></a>Spring Cloud Eureka简介</h2><p>Spring Cloud Eureka是Spring对Netflix Eureka的封装，使用Spring Boot风格的配置，开发人员只需要引入相关依赖，做一些简单配置就可以实现Eureka的功能。Spring Cloud Eureka分为两部分，Eureka Server和Eureka Client。</p>
<p>Eureka Server也就是我们上面提到的注册中心，和大多数注册中心框架一样，Eureka支持集群方式部署，以此达到高可用。Eureka的高可用是通过各个副本（Replica）互相注册来实现的，我们随后会对这一特性展开讨论。</p>
<p>Eureka Client主要提供服务的注册和发现，通过引入依赖的方式嵌入到微服务项目中，当Eureka Client启动时，会将自己注册到注册中心，并定期向注册中心发送心跳（Heartbeat）请求来续约。同时，Eureka Client还可以定期从注册中心查询可用的服务清单，缓存到本地并定期刷新。</p>
<h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><h3 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h3><p>新建一个Spring Boot工程<code>springcloud-eureka</code>，在<code>build.gradle</code>中引入依赖<code>spring-cloud-starter-eureka-server</code>依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-eureka-server'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring Boot的启动类上添加<code>@EnableEurekaServer</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.matrixstudio.springcloud.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>application.properties</code>文件中添加Eureka的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring application</span><br><span class="line">spring.application.name=springcloud-eureka</span><br><span class="line"></span><br><span class="line"># Server port</span><br><span class="line">server.port=8761</span><br><span class="line"></span><br><span class="line">management.security.enabled=false</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka</span><br><span class="line">eureka.instance.hostname=springcloud-eureka</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"></span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/</span><br></pre></td></tr></table></figure>
<p>然后启动<code>springcloud-eureka</code>项目，在浏览器中输入<code>http://localhost:8761/</code>就可以看到Eureka的Dashboard页面了。</p>
<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/_post/eureka-server-dashboard-01.png"></p>
<p>可以看到，在Instances currently registered with eureka下面的表格中没有数据，这是因为还没有服务注册到注册中心。</p>
<p>注册中心已经搭建完成，下面我们将微服务注册到Eureka Server上。</p>
<h3 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h3><p>在上一片文章<a href="https://lw900925.github.io/spring-cloud/spring-cloud-config.html">Spring Cloud 微服务：Spring Cloud Config</a>中我们创建了一个<code>springcloud-file-service</code>的项目作为Config Client，现在我们在该项目上添加Eureka Client的支持，使其注册到Eureka Server注册中心上。</p>
<p>首先需要引入依赖，<code>springcloud-file-service</code>项目中加入<code>spring-cloud-starter-eureka</code>起步依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.cloud:spring-cloud-starter-eureka'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>springcloud-file-service</code>项目的Spring Boot启动类，添加<code>@EnableDiscoveryClient</code>注解，开启Eureka Client功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.matrixstudio.springcloud.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FileServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要在<code>application.properties</code>文件中添加Eureka Server配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring application</span><br><span class="line">spring.application.name=springcloud-file-service</span><br><span class="line"></span><br><span class="line"># Server port</span><br><span class="line">server.port=8000</span><br><span class="line"></span><br><span class="line">management.security.enabled=false</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka discovery</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka/</span><br></pre></td></tr></table></figure>
<p>然后分别启动<code>springcloud-file-service</code>和<code>springcloud-eureka</code>项目，查看Eureka Server的Dashboard界面。</p>
<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/_post/eureka-server-dashboard-02.png"></p>
<p>可以看到Instances currently registered with eureka下方的表格内多了一个<code>SPRINGCLOUD-FILE-SERVICE</code>的服务，说明<code>springcloud-file-service</code>已经注册到Eureka Server上了。</p>
<p>也可以将<code>springcloud-file-service</code>部署多个实例，都注册到Eureka Server上，提高容错率（可以通过指定<code>profile</code>方式启动多个实例）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar springcloud-file-service-0.0.1-SNAPSHOT.jar --server.port=8000</span><br><span class="line">java -jar springcloud-file-service-0.0.1-SNAPSHOT.jar --server.port=8001</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/_post/eureka-server-dashboard-06.png"></p>
<p>查看Eureka Dashboard，发现列表中有两个<code>springcloud-file-service</code>的实例，端口分别为<code>8080</code>和<code>8081</code>。</p>
<h2 id="的高可用"><a href="#的高可用" class="headerlink" title="的高可用"></a>的高可用</h2><p>前面提到了注册中心的高可用，Eureka也可以配置为高可用注册中心。前面我们构建Eureka Server的时候，<code>application.properties</code>里有两个配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure>
<ul>
<li><code>eureka.client.register-with-eureka</code>：表示是否将注册到Eureka Server</li>
<li><code>eureka.client.fetch-registry</code>：表示是否获取注册中心的服务注册信息</li>
</ul>
<p>这两个配置默认值都是<code>true</code>，在构建Eureka Server时，由于Eureka Server是单机部署，所以Eureka不需要将自己注册到注册中心，也不需要获取服务清单。如果是集群部署，需要将这两个配置修改为默认值（或不指定这两个配置，默认就是<code>true</code>），Eureka Server通过集群中的副本之间相互注册，相互同步服务注册信息来达到高可用。</p>
<p>我们需要准备两个配置文件<code>application-replica1.properties</code>和<code>application-replica2.properties</code>，两个文件内容分别如下：</p>
<ul>
<li><code>application-replica1.properties</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring application</span><br><span class="line">spring.application.name=springcloud-eureka</span><br><span class="line"></span><br><span class="line">server.port=8761</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka instance</span><br><span class="line">eureka.instance.hostname=replica1</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka client</span><br><span class="line">eureka.client.service-url.defaultZone=http://replica2:8762/eureka/</span><br></pre></td></tr></table></figure>
<ul>
<li><code>application-replica2.properties</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring application</span><br><span class="line">spring.application.name=springcloud-eureka</span><br><span class="line"></span><br><span class="line">server.port=8762</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka instance</span><br><span class="line">eureka.instance.hostname=replica2</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka client</span><br><span class="line">eureka.client.service-url.defaultZone=http://replica1:8761/eureka/</span><br></pre></td></tr></table></figure>
<p><strong><em> 注：</em></strong> 需要在<code>hosts</code>文件中添加<code>replica1</code>和<code>replica2</code>的映射，让Eureka能通过<code>hosts</code>访问的到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Eureka Replica Start</span><br><span class="line">127.0.0.1 replica1</span><br><span class="line">127.0.0.1 replica2</span><br><span class="line"># Eureka Replica End</span><br></pre></td></tr></table></figure>
<p>分别将Eureka的两个副本启动起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar springcloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=replica1</span><br><span class="line">java -jar springcloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=replica2</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/_post/eureka-server-dashboard-03.png"></p>
<p>浏览器输入<code>http://localhost:8761/</code>查看<code>replica1</code>副本的Dashboard页面，注意页面中DS Replicas下方的列表，此时多出一个<code>replica2</code>的副本，然后查看另一个副本的Dashboard页面，发现DS Replicas下方多出了<code>replica2</code>的副本。</p>
<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/_post/eureka-server-dashboard-04.png"></p>
<p>此时可以将<code>springcloud-file-service</code>服务注册到Eureka Server集群上，修改<code>application.properties</code>配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Spring application</span><br><span class="line">spring.application.name=springcloud-file-service</span><br><span class="line"></span><br><span class="line"># Server port</span><br><span class="line">server.port=8000</span><br><span class="line"></span><br><span class="line">management.security.enabled=false</span><br><span class="line"></span><br><span class="line"># Spring cloud eureka discovery</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone=http://replica1:8761/eureka/,http://replica2:8762/eureka/</span><br></pre></td></tr></table></figure>
<h2 id="将配置中心注册在Eureka上"><a href="#将配置中心注册在Eureka上" class="headerlink" title="将配置中心注册在Eureka上"></a>将配置中心注册在Eureka上</h2><p>在上一片文章<a href="https://lw900925.github.io/spring-cloud/spring-cloud-config.html">Spring Cloud 微服务：Spring Cloud Config</a>中我们介绍了Spring Cloud Config的配置中心——Config Server，Config Server也可以看作一个微服务，既然是微服务，应该要支持高可用。</p>
<p>Config Server高可用有两种部署方式，一种是直接部署成多个实例，通过Nginx等反向代理工具做负载均衡；还有一种就是通过注册到Eureka Server上实现高可用，配置方法和Eureka Client配置方法一致。</p>
<p>需要注意的是，如果将Config Server注册到Eureka Server上，Config Client端获取配置的方式需要指定为从Eureka Server的服务清单中获取。在<code>springcloud-file-service</code>的<code>application.properties</code>文件中添加下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.discovery.enabled=true</span><br><span class="line">spring.cloud.config.discovery.service-id=springcloud-config-server</span><br></pre></td></tr></table></figure>
<p>最后，附上项目源码地址：</p>
<ul>
<li>spring-cloud：<a href="https://github.com/lw900925/springcloud" target="_blank" rel="noopener">https://github.com/lw900925/springcloud</a></li>
<li>spring-cloud-config-repository (github): <a href="https://github.com/lw900925/springcloud-config-repository" target="_blank" rel="noopener">https://github.com/lw900925/springcloud-config-repository</a></li>
<li>spring-cloud-config-repository (gitlab): <a href="https://gitlab.com/lw900925/springcloud-config-repository" target="_blank" rel="noopener">https://gitlab.com/lw900925/springcloud-config-repository</a></li>
</ul>
<p>如果有疑问，请在下方评论区参与讨论。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>2017年终总结（一篇迟到的年终总结）</title>
    <url>/year-end-summary/2017.html</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/lw900925/blog-asset/master/images/banner/2017.jpg"></p>
<a id="more"></a>
<p>公元2018年1月22日，就是公司开年会的前一天，我独自在公司门口外徘徊，遇见同事李君，前来问我道：“先生可曾写过年终总结没有？” 我说“没有”。他就正告我，“先生还是写一点罢，我们都很爱看先生的文章。” 于是就有了这篇年终总结。</p>
<p>回顾2017年，总体感觉还是收获满满，工作中学到到一些新的技术和概念，在开源社区也认识了不少朋友。总结起来，也就从以下几个方面说起。</p>
<h1 id="关于公司（透云科技）"><a href="#关于公司（透云科技）" class="headerlink" title="关于公司（透云科技）"></a>关于公司（透云科技）</h1><p>我是2016年5月入职这家公司，在入职透云科技之前，我在一家初创公司呆过2年。刚到透云的时候，由于之前工作中养成的一些坏习惯，以及自身技术基础掌握不到位，工作效率和质量都不高，试用期的前3个月感觉压力很大。好在这里的同事都比较好相处，领导们为人也比较随和，没有那种高高在上的领导架子，遇到问题及时请教他们，他们都会给我帮助或者建议。</p>
<p>我所在的部门技术氛围比较好，部门或者开发小组会不定期的举行一些技术分享会议，比如项目中需要用到某项新技术，会安排一个不太忙的A同事去研究，A同事会将自己的研究成果通过会议分享出来。当然这种分享只能算是了解，如果想要达到熟练使用的程度，得需要深入了解。我自己比较看好这种技术分享，可以帮助大家共同提高。可能是我们的部门主管是技术出身，同时他也比较看重这一点，想打造一支技术过硬的团队的缘故吧。</p>
<h1 id="技术收获"><a href="#技术收获" class="headerlink" title="技术收获"></a>技术收获</h1><p>上半年公司组织架构调整，两个事业部合并，统一成立了一个研发部。由于之前两个事业部的平台在业务功能上有好多重复，维护两个平台也会增加成本，所以决定开发一套新的平台。新平台采用目前比较流行的微服务架构模式，最终技术选型为<a href="https://projects.spring.io/spring-cloud/" title="Spring Cloud" target="_blank" rel="noopener">Spring Cloud</a>，我有幸被安排研究了Spring Cloud框架。在这过程中，遇到了不少坑，Spring Cloud又是比较新的技术，资料也比较少，遇到那种Google都搜不到的问题只能自己想办法：反复查看官方手册，阅读源吗，甚至跑去GitHub上提Issue。这些坑踩过一遍之后，觉得也能满足团队的开发需求，最终决定用Spring Cloud。</p>
<p>早在年初的时候抽空学习了Java 8的新特性，整理了几篇文章，那段时间也比较闲，就尝试着用Java 8提倡的函数式编程方式重构了一遍原来的代码，重构后的代码简洁了许多，可读性也好很多。特别是Stream API，配合Lambda表达式，可以很大程度上简化Java之前版本对集合的操作。</p>
<h1 id="对自己的期望"><a href="#对自己的期望" class="headerlink" title="对自己的期望"></a>对自己的期望</h1><p>想想自己从毕业到现在已经有5个年头了，有时候会拿现在的自己和当初刚毕业时的自己做对比，每次对比都觉得其实还有好多自己没有达到的期望。对于未来的发展，我依然不敢懈怠，因为技术发展真的太快了，我刚毕业的时候，用的还是比较传统的Java EE，JSP + Servlet开发Web应用，当时最火最流行的框架就是SSH（Struts2 + Spring + Hibernate），而现在，各种新的技术层出不穷：前后端分离、微服务架构、深度学习、大数据等，稍有懈怠就会跟不上技术的发展潮流而被淘汰，所以必须时刻保持对这个行业的敏锐嗅探，让自己不要落伍，同时深耕技术，保持自己的竞争力。</p>
<h1 id="个人生活"><a href="#个人生活" class="headerlink" title="个人生活"></a>个人生活</h1><p>今年业余生活挺单调的，偶尔周末陪女朋友逛逛街，或者去看场电影，也没有出去旅行。原本给自己定制的增肥计划也没能实现，身体也越来越差，这个冬天竟然感冒了两次。</p>
<p>跟女朋友谈了2年恋爱，明年打算结婚了，我们也算即将修成正果，这场恋爱谈的磕磕绊绊，两个人都很疲惫，好在最后我们都还在一起，这一路走来也不容易，应该珍惜眼前的人。</p>
<p>今年年初的时候开通了这个博客，断断续续写过几篇文章，也没做SEO和推广，所以一直没有访问量。上个月做了Google的Search Console，没过几天博客就被Google收录了，访问量一下提高了很多，但是由于众所周知的原因（好吧，是因为博客托管在GitHub Pages上，GitHub禁用了百度的爬虫程序，导致无法被百度收录），无法被百度收录，也算是一点遗憾。现在每天平均的访问量大概在20-40左右，有时候能达到80。今天某网站来信给我希望收录我的文章，这也给我很大鼓励，后期我会经常更新博客，尽可能发表高质量的干货文章。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>文章开头那一段话是我模仿鲁迅先生的<a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%B5%E5%88%98%E5%92%8C%E7%8F%8D%E5%90%9B" title="记念刘和珍君" target="_blank" rel="noopener">《记念刘和珍君》</a>写的，结尾也还用这种方式吧，麻烦帮我按住鲁迅的棺材板，谢谢。</p>
<p>呜呼，我说不出话，但以此记念我的2017年！</p>
<p>一月二十二日</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
  </entry>
</search>
